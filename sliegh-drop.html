<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Santa's Sleigh Drop</title>
    <!-- Tailwind CSS for utility classes -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');

        /* Custom festive styles */
        body {
            background-color: #0b1a2d;
            /* Dark Night Sky */
            font-family: 'Fredoka One', cursive;
            margin: 0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            user-select: none;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            /* Let clicks pass through to canvas/controls */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .controls {
            pointer-events: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
        }

        .action-button {
            padding: 20px 40px;
            font-size: 1.8rem;
            font-weight: bold;
            color: white;
            background-color: #cc0000;
            /* Santa Red */
            border: 4px solid #ffcc00;
            /* Gold Border */
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.1s ease;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.4);
            box-shadow: 0 6px #990000;
        }

        .action-button:hover {
            background-color: #ff3333;
            transform: scale(1.05);
        }

        .action-button:active {
            box-shadow: 0 2px #990000;
            transform: translateY(4px) scale(1.05);
        }

        .score-display {
            color: #ffcc00;
            /* Gold */
            text-shadow: 2px 2px 4px #000;
            font-size: 2rem;
            pointer-events: auto;
        }

        .instruction-bar {
            background-color: rgba(0, 128, 0, 0.8);
            /* Deep Green with opacity */
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            text-align: center;
            font-size: 1.1rem;
            text-shadow: 1px 1px 2px #000;
            pointer-events: auto;
            align-self: center;
            backdrop-filter: blur(5px);
            border: 2px solid #fff;
        }

        /* Message Box Styling */
        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 25px;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            text-align: center;
            z-index: 20;
            border: 8px solid #cc0000;
            color: #0b1a2d;
            pointer-events: auto;
            min-width: 300px;
        }

        .message-box h2 {
            font-size: 3rem;
            color: #cc0000;
            margin-bottom: 15px;
        }

        .message-box p {
            font-size: 1.5rem;
            margin-bottom: 30px;
        }

        .message-box button {
            background-color: #008000;
            color: white;
            padding: 15px 30px;
            font-size: 1.3rem;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 5px #005900;
            transition: background-color 0.1s;
        }

        .message-box button:active {
            box-shadow: 0 0 #005900;
            transform: translateY(4px);
        }
    </style>
</head>

<body>

    <canvas id="gameCanvas"></canvas>

    <div class="ui-layer">
        <div style="display: flex; justify-content: space-between; width: 100%; align-items: flex-start;">
            <div class="score-display">Delivered: <span id="scoreValue">0</span> / <span id="maxScoreValue">10</span>
            </div>
            <div class="instruction-bar">
                Use <strong>Arrow Keys</strong> to fly. <strong>Spacebar</strong> to drop gifts! Avoid chimneys!
            </div>
        </div>

        <div class="controls">
            <button class="action-button" onclick="dropGift()">DROP GIFT!</button>
        </div>
    </div>

    <!-- Message Box Template (Hidden by default) -->
    <div id="messageBox" class="message-box hidden">
        <h2 id="messageTitle">Mission Complete!</h2>
        <p>You successfully delivered <span id="finalScore">0</span> presents!</p>
        <button onclick="restartGame()">Play Again</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreValueDisplay = document.getElementById('scoreValue');
        const maxScoreValueDisplay = document.getElementById('maxScoreValue');
        const messageBox = document.getElementById('messageBox');
        const finalScoreDisplay = document.getElementById('finalScore');

        // --- Configuration ---
        let GAME_WIDTH = window.innerWidth;
        let GAME_HEIGHT = window.innerHeight;
        let GROUND_Y = GAME_HEIGHT - 100; // Ground is 100px from bottom

        const SLEIGH_WIDTH = 100;
        const SLEIGH_COLLISION_HEIGHT = 30;
        const BASE_SCROLL_SPEED = 4.0;
        const SLEIGH_MOVE_SPEED = 6;

        // Reindeer Configuration
        const REINDEER_COUNT = 4;
        const REINDEER_SIZE = 12;
        const REINDEER_SPACING = 45;

        const GIFT_SIZE = 20;
        const GIFT_VELOCITY = 6;
        const CHIMNEY_WIDTH = 40;
        const CHIMNEY_MIN_HEIGHT = 60;
        const CHIMNEY_MAX_HEIGHT = 150;
        const MAX_SCORE = 10;

        // --- Game State ---
        let score = 0;
        let isRunning = true;
        let sleighX = 100;
        let sleighY = 100;
        let team = []; // Array of {x, y, targetY} for reindeer and sleigh
        let houses = [];
        let fallingGifts = [];
        let snowParticles = [];
        let stars = [];
        let mountains = [];
        let bgTrees = [];
        let particles = []; // Trail and smoke
        let popups = []; // Score and text
        let santaSpeech = null;
        let lastHouseX = GAME_WIDTH;
        let keys = {};
        let currentScrollSpeed = BASE_SCROLL_SPEED;

        // Set up the canvas dimensions
        function resize() {
            GAME_WIDTH = window.innerWidth;
            GAME_HEIGHT = window.innerHeight;
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;
            GROUND_Y = GAME_HEIGHT - 100;
        }
        window.addEventListener('resize', resize);
        resize();

        maxScoreValueDisplay.textContent = MAX_SCORE;

        // --- Graphics Helpers ---
        function initStars() {
            stars = [];
            for (let i = 0; i < 150; i++) {
                stars.push({
                    x: Math.random() * GAME_WIDTH,
                    y: Math.random() * (GROUND_Y - 100),
                    size: Math.random() * 2 + 0.5,
                    speed: Math.random() * 0.5 + 0.1,
                    twinkle: Math.random() * Math.PI
                });
            }
        }

        function initSnow() {
            snowParticles = [];
            for (let i = 0; i < 150; i++) {
                snowParticles.push({
                    x: Math.random() * GAME_WIDTH,
                    y: Math.random() * GAME_HEIGHT,
                    radius: Math.random() * 3 + 1,
                    speedY: Math.random() * 2 + 1,
                    speedX: Math.random() * 1 - 0.5
                });
            }
        }

        function initMountains() {
            mountains = [];
            let x = -200;
            while (x < GAME_WIDTH * 2) {
                const w = Math.random() * 400 + 300;
                const h = Math.random() * 250 + 150;
                mountains.push({ x: x, w: w, h: h, color: '#152a45' });
                x += w - Math.random() * 150;
            }
        }

        function initBgTrees() {
            bgTrees = [];
            let x = -100;
            while (x < GAME_WIDTH * 2) {
                if (Math.random() > 0.2) {
                    bgTrees.push({
                        x: x,
                        y: GROUND_Y,
                        w: Math.random() * 40 + 30,
                        h: Math.random() * 100 + 60,
                        color: '#1e3c2e'
                    });
                }
                x += Math.random() * 60 + 30;
            }
        }

        // --- House Class ---
        class House {
            constructor(startX) {
                this.x = startX;
                this.width = Math.random() * 150 + 200;
                this.height = Math.random() * 150 + 100;
                this.baseY = GROUND_Y;
                this.profilePoints = [];
                this.chimney = null;
                this.roofLine = [];
                this.windows = [];
                // Randomize house color slightly
                const colors = ['#2c3e50', '#34495e', '#2e4053', '#283747'];
                this.color = colors[Math.floor(Math.random() * colors.length)];
                this.generateShape();
                this.generateWindows();
            }

            generateShape() {
                const shapeType = Math.floor(Math.random() * 3);
                const roofY = this.baseY - this.height;

                // Define the roof line
                switch (shapeType) {
                    case 0: // Flat Roof
                        this.roofLine.push({ dx: 0, dy: roofY });
                        this.roofLine.push({ dx: this.width, dy: roofY });
                        break;
                    case 1: // Peaked
                        const peakX = this.width * 0.5;
                        const peakY = roofY - Math.random() * 80 - 40;
                        this.roofLine.push({ dx: 0, dy: roofY });
                        this.roofLine.push({ dx: peakX, dy: peakY });
                        this.roofLine.push({ dx: this.width, dy: roofY });
                        break;
                    case 2: // Slanted
                        this.roofLine.push({ dx: 0, dy: roofY });
                        this.roofLine.push({ dx: this.width, dy: roofY - 40 });
                        break;
                }

                this.profilePoints.push({ dx: 0, dy: this.baseY });
                this.profilePoints.push(...this.roofLine.map(p => ({ dx: p.dx, dy: p.dy })));
                this.profilePoints.push({ dx: this.width, dy: this.baseY });

                this.generateChimney();
            }

            generateChimney() {
                let roofY = this.roofLine[0].dy;
                let chimneyXOffset = this.width * 0.5;

                // Find a reasonably flat segment to place the chimney
                let flatSegments = this.roofLine.slice(0, -1).filter((p1, i) => {
                    const p2 = this.roofLine[i + 1];
                    return p2.dx - p1.dx > CHIMNEY_WIDTH + 10 && Math.abs(p1.dy - p2.dy) < 20;
                });

                if (flatSegments.length > 0) {
                    const segmentIndex = Math.floor(Math.random() * flatSegments.length);
                    const p1 = flatSegments[segmentIndex];
                    const p2 = this.roofLine[this.roofLine.indexOf(p1) + 1];
                    roofY = Math.min(p1.dy, p2.dy);
                    chimneyXOffset = p1.dx + Math.random() * (p2.dx - p1.dx - CHIMNEY_WIDTH);
                } else {
                    chimneyXOffset = this.width * 0.5;
                    roofY = this.roofLine[0].dy;
                }

                chimneyXOffset = Math.max(20, Math.min(chimneyXOffset, this.width - CHIMNEY_WIDTH - 20));
                const chimneyHeight = Math.random() * (CHIMNEY_MAX_HEIGHT - CHIMNEY_MIN_HEIGHT) + CHIMNEY_MIN_HEIGHT;

                this.chimney = {
                    x: this.x + chimneyXOffset,
                    y: roofY - chimneyHeight,
                    width: CHIMNEY_WIDTH,
                    height: chimneyHeight,
                    isHit: false,
                    roofTopY: roofY
                };
            }

            generateWindows() {
                const rows = Math.floor(this.height / 60);
                const cols = Math.floor(this.width / 50);
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        if (Math.random() > 0.3) {
                            this.windows.push({
                                x: 20 + c * 50,
                                y: this.baseY - 40 - r * 60,
                                w: 30,
                                h: 40,
                                lit: Math.random() > 0.2
                            });
                        }
                    }
                }
            }
        }

        // --- Drawing Functions ---

        function drawSleigh() {
            // --- Draw Sleigh (Detailed) ---
            const sleighBodyGradient = ctx.createLinearGradient(sleighX, sleighY, sleighX, sleighY + 40);
            sleighBodyGradient.addColorStop(0, '#d60000');
            sleighBodyGradient.addColorStop(1, '#990000');

            // Runners (Gold)
            ctx.strokeStyle = '#ffcc00';
            ctx.lineWidth = 4;
            ctx.beginPath();
            // Main runner curve
            ctx.moveTo(sleighX + 10, sleighY + 35);
            ctx.bezierCurveTo(sleighX - 10, sleighY + 35, sleighX - 10, sleighY + 5, sleighX, sleighY + 5); // Back curl
            ctx.moveTo(sleighX + 10, sleighY + 35);
            ctx.lineTo(sleighX + 90, sleighY + 35);
            ctx.bezierCurveTo(sleighX + 110, sleighY + 35, sleighX + 110, sleighY + 15, sleighX + 100, sleighY + 10); // Front curl
            ctx.stroke();

            // Sleigh Body
            ctx.fillStyle = sleighBodyGradient;
            ctx.beginPath();
            ctx.moveTo(sleighX, sleighY + 10);
            ctx.bezierCurveTo(sleighX - 10, sleighY + 30, sleighX + 20, sleighY + 35, sleighX + 50, sleighY + 35); // Bottom curve
            ctx.lineTo(sleighX + 90, sleighY + 35);
            ctx.quadraticCurveTo(sleighX + 100, sleighY + 35, sleighX + 100, sleighY + 20); // Front
            ctx.lineTo(sleighX + 80, sleighY + 20);
            ctx.quadraticCurveTo(sleighX + 60, sleighY + 30, sleighX + 40, sleighY + 20); // Side dip
            ctx.lineTo(sleighX, sleighY + 10); // Back
            ctx.fill();

            // Gold Trim
            ctx.strokeStyle = '#ffcc00';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Bag of Toys
            ctx.fillStyle = '#8B4513'; // Brown sack
            ctx.beginPath();
            ctx.arc(sleighX + 20, sleighY + 15, 12, 0, Math.PI * 2);
            ctx.fill();
            // Some patches/details on bag
            ctx.fillStyle = '#A0522D';
            ctx.beginPath();
            ctx.arc(sleighX + 22, sleighY + 12, 5, 0, Math.PI * 2);
            ctx.fill();


            // Santa
            // Body
            ctx.fillStyle = '#cc0000';
            ctx.beginPath();
            ctx.ellipse(sleighX + 50, sleighY + 10, 12, 15, 0, 0, Math.PI * 2);
            ctx.fill();

            // Belt
            ctx.fillStyle = 'black';
            ctx.fillRect(sleighX + 40, sleighY + 10, 20, 4);
            ctx.fillStyle = 'gold';
            ctx.strokeRect(sleighX + 48, sleighY + 10, 4, 4);

            // Head
            ctx.fillStyle = '#ffcc99';
            ctx.beginPath();
            ctx.arc(sleighX + 50, sleighY - 5, 8, 0, Math.PI * 2);
            ctx.fill();

            // Beard
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.moveTo(sleighX + 42, sleighY - 5);
            ctx.quadraticCurveTo(sleighX + 50, sleighY + 10, sleighX + 58, sleighY - 5);
            ctx.fill();

            // Hat
            ctx.fillStyle = '#cc0000';
            ctx.beginPath();
            ctx.moveTo(sleighX + 40, sleighY - 8);
            ctx.quadraticCurveTo(sleighX + 50, sleighY - 20, sleighX + 60, sleighY - 8);
            ctx.fill();
            // Pom pom
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(sleighX + 60, sleighY - 8, 3, 0, Math.PI * 2);
            ctx.fill();
            // Hat Trim
            ctx.fillStyle = 'white';
            ctx.fillRect(sleighX + 40, sleighY - 9, 20, 3);

            // Arm (Waving)
            ctx.strokeStyle = '#cc0000';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(sleighX + 50, sleighY + 5);
            const wave = Math.sin(Date.now() / 200) * 5;
            ctx.lineTo(sleighX + 60, sleighY - 5 + wave);
            ctx.stroke();
            // Mitten
            ctx.fillStyle = '#006400'; // Green mitten
            ctx.beginPath();
            ctx.arc(sleighX + 60, sleighY - 5 + wave, 4, 0, Math.PI * 2);
            ctx.fill();

            // --- Reindeer Team ---
            for (let i = 0; i < REINDEER_COUNT; i++) {
                const rX = team[i].x;
                const rY = team[i].y + 15 + Math.sin(Date.now() / 300 + i) * 3; // Slight bobbing

                // Calculate rotation based on Y velocity (difference from target)
                const yDiff = team[i].targetY - team[i].y;
                const rotation = Math.atan2(yDiff, 50) * 0.5; // Subtle rotation based on vertical movement

                ctx.save();
                ctx.translate(rX, rY);
                ctx.rotate(rotation);

                // Reindeer Body (drawn relative to 0,0 now)
                ctx.fillStyle = '#8B4513'; // Brown
                ctx.beginPath();
                ctx.ellipse(0, 0, 15, 8, 0, 0, Math.PI * 2);
                ctx.fill();

                // Neck & Head
                ctx.beginPath();
                ctx.moveTo(10, 0);
                ctx.lineTo(20, -15);
                ctx.lineTo(15, -15);
                ctx.lineTo(5, 0);
                ctx.fill();

                // Head
                ctx.beginPath();
                ctx.ellipse(22, -18, 8, 5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Ears
                ctx.beginPath();
                ctx.moveTo(18, -20);
                ctx.lineTo(15, -25);
                ctx.lineTo(20, -22);
                ctx.fill();

                // Legs (Animated)
                const legAnim = Math.sin(Date.now() / 100 + i) * 8;
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 2;

                // Front Legs
                ctx.beginPath();
                ctx.moveTo(10, 5);
                ctx.lineTo(10 + legAnim, 20);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(10, 5);
                ctx.lineTo(10 - legAnim, 20);
                ctx.stroke();

                // Back Legs
                ctx.beginPath();
                ctx.moveTo(-10, 5);
                ctx.lineTo(-10 + legAnim, 20);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(-10, 5);
                ctx.lineTo(-10 - legAnim, 20);
                ctx.stroke();

                // Antlers
                ctx.strokeStyle = '#D2B48C';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(20, -22);
                ctx.lineTo(25, -35);
                ctx.moveTo(22, -28);
                ctx.lineTo(28, -30);
                ctx.stroke();

                // Nose (Rudolph i=0)
                if (i === 0) {
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(28, -18, 3, 0, Math.PI * 2);
                    ctx.fill();
                    // Glow
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.6)';
                    ctx.beginPath();
                    ctx.arc(28, -18, 8, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(28, -18, 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();

                // Reins (drawn outside rotation)
                ctx.strokeStyle = '#c0c0c0';
                ctx.lineWidth = 1;
                ctx.beginPath();
                if (i < REINDEER_COUNT - 1) {
                    const nextRX = team[i + 1].x;
                    const nextRY = team[i + 1].y + 10;
                    ctx.moveTo(rX, rY - 5);
                    ctx.lineTo(nextRX, nextRY);
                } else {
                    ctx.moveTo(rX, rY - 5);
                    ctx.lineTo(sleighX + 100, sleighY + 15);
                }
                ctx.stroke();
            }
        }

        function drawGift(gift) {
            ctx.fillStyle = '#008000';
            ctx.fillRect(gift.x, gift.y, GIFT_SIZE, GIFT_SIZE);
            ctx.fillStyle = '#cc0000';
            ctx.fillRect(gift.x + GIFT_SIZE / 2 - 3, gift.y, 6, GIFT_SIZE);
            ctx.fillRect(gift.x, gift.y + GIFT_SIZE / 2 - 3, GIFT_SIZE, 6);
        }

        function drawChimney(chimney) {
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(chimney.x, chimney.y, CHIMNEY_WIDTH, chimney.height);
            // Bricks
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let y = chimney.y; y < chimney.y + chimney.height; y += 10) {
                ctx.moveTo(chimney.x, y);
                ctx.lineTo(chimney.x + CHIMNEY_WIDTH, y);
            }
            ctx.stroke();

            ctx.fillStyle = '#333333';
            ctx.fillRect(chimney.x - 5, chimney.y, CHIMNEY_WIDTH + 10, 12);

            if (chimney.isHit) {
                ctx.fillStyle = '#ffcc00';
                ctx.font = '30px Fredoka One';
                ctx.fillText('â­', chimney.x + CHIMNEY_WIDTH / 2 - 15, chimney.y - 15);
            }
        }

        function drawHouse(house) {
            // Building Body
            ctx.fillStyle = house.color;
            ctx.beginPath();
            for (const p of house.profilePoints) {
                ctx.lineTo(house.x + p.dx, p.dy);
            }
            ctx.closePath();
            ctx.fill();

            // Windows
            for (const w of house.windows) {
                ctx.fillStyle = w.lit ? '#f1c40f' : '#1a252f';
                ctx.fillRect(house.x + w.x, w.y, w.w, w.h);
                // Frame
                ctx.strokeStyle = house.color;
                ctx.lineWidth = 2;
                ctx.strokeRect(house.x + w.x, w.y, w.w, w.h);
                // Cross
                ctx.beginPath();
                ctx.moveTo(house.x + w.x + w.w / 2, w.y);
                ctx.lineTo(house.x + w.x + w.w / 2, w.y + w.h);
                ctx.moveTo(house.x + w.x, w.y + w.h / 2);
                ctx.lineTo(house.x + w.x + w.w, w.y + w.h / 2);
                ctx.stroke();
            }

            // Snowy Roof
            ctx.fillStyle = '#ecf0f1';
            ctx.beginPath();
            const startP = house.roofLine[0];
            ctx.moveTo(house.x + startP.dx, startP.dy);
            for (let i = 1; i < house.roofLine.length; i++) {
                const p = house.roofLine[i];
                ctx.lineTo(house.x + p.dx, p.dy);
            }
            const endP = house.roofLine[house.roofLine.length - 1];
            ctx.lineTo(house.x + endP.dx, endP.dy + 8);
            ctx.lineTo(house.x + startP.dx, startP.dy + 8);
            ctx.closePath();
            ctx.fill();

            if (house.chimney) {
                drawChimney(house.chimney);
            }
        }

        function generateHouse() {
            const newHouse = new House(lastHouseX + Math.random() * 150 + 100);
            houses.push(newHouse);
            lastHouseX = newHouse.x + newHouse.width;
        }

        function endGame(win = false, reason = "win") {
            isRunning = false;
            messageBox.classList.remove('hidden');
            finalScoreDisplay.textContent = score;

            if (win) {
                document.getElementById('messageTitle').textContent = "Mission Complete!";
                document.getElementById('messageBox').querySelector('p').textContent = `You successfully delivered all ${MAX_SCORE} presents! Time for milk and cookies.`;
            } else if (reason === "crash") {
                document.getElementById('messageTitle').textContent = "Mission Failed!";
                document.getElementById('messageBox').querySelector('p').textContent = `Oh no! Santa crashed into a chimney! You delivered ${score} presents.`;
            } else {
                document.getElementById('messageTitle').textContent = "Game Over!";
                document.getElementById('messageBox').querySelector('p').textContent = `You delivered ${score} presents. Try to reach ${MAX_SCORE}!`;
            }
        }

        // --- Game Logic ---

        function update() {
            if (!isRunning) return;

            currentScrollSpeed = BASE_SCROLL_SPEED + (Math.sin(Date.now() / 1000) * 0.5);

            // --- 1. Team Follow-the-Leader Movement ---
            // Lead reindeer (index 0) follows player input
            if (keys['ArrowLeft']) { team[0].x -= SLEIGH_MOVE_SPEED; }
            if (keys['ArrowRight']) { team[0].x += SLEIGH_MOVE_SPEED; }
            if (keys['ArrowUp']) { team[0].targetY -= SLEIGH_MOVE_SPEED; }
            if (keys['ArrowDown']) { team[0].targetY += SLEIGH_MOVE_SPEED; }

            // Smooth Y movement for lead reindeer
            const smoothFactor = 0.15;
            team[0].y += (team[0].targetY - team[0].y) * smoothFactor;

            // Each subsequent member follows the one in front
            for (let i = 1; i < team.length; i++) {
                const leader = team[i - 1];
                const follower = team[i];

                // Follow X position directly (maintain spacing)
                follower.x = leader.x - REINDEER_SPACING;

                // Follow Y with slight delay
                follower.targetY = leader.y;
                follower.y += (follower.targetY - follower.y) * smoothFactor * 0.8;
            }

            // Keep team within bounds
            const totalTeamLength = SLEIGH_WIDTH + (REINDEER_COUNT * REINDEER_SPACING) + 20;
            team[0].x = Math.max(20, Math.min(team[0].x, GAME_WIDTH - totalTeamLength));
            const groundLimitY = GROUND_Y - SLEIGH_COLLISION_HEIGHT;
            team[0].targetY = Math.max(20, Math.min(team[0].targetY, groundLimitY));

            // Update sleighX and sleighY from the last team member (the sleigh)
            sleighX = team[team.length - 1].x - SLEIGH_WIDTH;
            sleighY = team[team.length - 1].y;

            // --- 2. World Scrolling (Houses, Mountains, Trees) ---
            for (const house of houses) {
                house.x -= currentScrollSpeed;
                if (house.chimney) {
                    house.chimney.x -= currentScrollSpeed;
                    // Chimney Smoke
                    if (Math.random() > 0.9) {
                        particles.push({
                            x: house.chimney.x + CHIMNEY_WIDTH / 2,
                            y: house.chimney.y,
                            vx: Math.random() * 0.5 - 0.25,
                            vy: -1 - Math.random(),
                            life: 1.0,
                            size: Math.random() * 5 + 2,
                            type: 'smoke'
                        });
                    }
                }
            }

            // Mountains Parallax (Slow)
            for (const m of mountains) {
                m.x -= currentScrollSpeed * 0.1;
            }
            // Loop mountains
            if (mountains.length > 0 && mountains[0].x + mountains[0].w < -100) {
                const first = mountains.shift();
                const last = mountains[mountains.length - 1];
                first.x = last.x + last.w - Math.random() * 50;
                mountains.push(first);
            }

            // Trees Parallax (Medium)
            for (const t of bgTrees) {
                t.x -= currentScrollSpeed * 0.5;
            }
            // Loop trees
            if (bgTrees.length > 0 && bgTrees[0].x < -50) {
                const first = bgTrees.shift();
                const last = bgTrees[bgTrees.length - 1];
                first.x = last.x + Math.random() * 60 + 30;
                bgTrees.push(first);
            }


            // Stars Parallax
            for (const star of stars) {
                star.x -= currentScrollSpeed * star.speed;
                if (star.x < 0) star.x = GAME_WIDTH;
                star.twinkle += 0.1;
            }

            // Snow
            for (const snow of snowParticles) {
                snow.y += snow.speedY;
                snow.x += snow.speedX - currentScrollSpeed * 0.1;
                if (snow.y > GAME_HEIGHT) {
                    snow.y = -10;
                    snow.x = Math.random() * GAME_WIDTH;
                }
            }

            // Sleigh Trail Particles
            if (Math.random() > 0.5) {
                particles.push({
                    x: sleighX + 10,
                    y: sleighY + 35,
                    vx: -currentScrollSpeed,
                    vy: Math.random() * 1 - 0.5,
                    life: 1.0,
                    size: Math.random() * 3 + 1,
                    type: 'trail'
                });
            }

            // Update Particles
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.02;
                return p.life > 0;
            });

            // Update Popups
            popups = popups.filter(p => {
                p.y -= 1;
                p.life -= 0.02;
                return p.life > 0;
            });

            // Update Santa Speech
            if (santaSpeech) {
                santaSpeech.life -= 0.01;
                santaSpeech.x = sleighX + 50;
                santaSpeech.y = sleighY - 40;
                if (santaSpeech.life <= 0) santaSpeech = null;
            } else if (Math.random() > 0.997) {
                santaSpeech = { text: "Ho Ho Ho!", life: 2.0, x: sleighX + 50, y: sleighY - 40 };
            }


            if (lastHouseX < GAME_WIDTH + 200) {
                generateHouse();
            }

            houses = houses.filter(h => h.x + h.width > -50);
            lastHouseX = houses.length > 0 ? Math.max(lastHouseX, houses[houses.length - 1].x + houses[houses.length - 1].width) : GAME_WIDTH;

            // --- 3. Check for Sleigh Collision with Chimneys ---
            for (const house of houses) {
                if (!house.chimney) continue;
                const chimney = house.chimney;

                const sleighTop = sleighY;
                const sleighBottom = sleighY + SLEIGH_COLLISION_HEIGHT;
                const sleighLeft = sleighX;
                const sleighRight = sleighX + SLEIGH_WIDTH;

                const chimneyTop = chimney.y;
                const chimneyBottom = chimney.roofTopY;
                const chimneyLeft = chimney.x;
                const chimneyRight = chimney.x + CHIMNEY_WIDTH;

                const isHorizontalOverlap = sleighRight > chimneyLeft && sleighLeft < chimneyRight;
                const isVerticalOverlap = sleighBottom > chimneyTop && sleighTop < chimneyBottom;

                if (isHorizontalOverlap && isVerticalOverlap) {
                    endGame(false, "crash");
                    return;
                }
            }

            // --- 4. Update Falling Gifts ---
            fallingGifts = fallingGifts.filter(gift => {
                gift.y += GIFT_VELOCITY;
                gift.x -= currentScrollSpeed;

                for (const house of houses) {
                    if (!house.chimney) continue;
                    const chimney = house.chimney;
                    const isHorizontalOverlap = gift.x + GIFT_SIZE > chimney.x && gift.x < chimney.x + CHIMNEY_WIDTH;
                    const hasLanded = gift.y + GIFT_SIZE >= chimney.y && gift.y + GIFT_SIZE < chimney.y + 10;

                    if (isHorizontalOverlap && hasLanded && !chimney.isHit) {
                        score++;
                        scoreValueDisplay.textContent = score;
                        chimney.isHit = true;

                        // Feedback
                        popups.push({ x: chimney.x + 20, y: chimney.y - 20, text: "+1", life: 1.0, color: '#ffcc00' });
                        santaSpeech = { text: "Merry Christmas!", life: 1.5, x: sleighX + 50, y: sleighY - 40 };

                        if (score >= MAX_SCORE) { endGame(true); }
                        return false;
                    }
                }
                if (gift.y > GAME_HEIGHT) { return false; }
                return true;
            });
        }

        function draw() {
            // Sky Gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
            gradient.addColorStop(0, '#0b1a2d');
            gradient.addColorStop(1, '#1a3a60');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            // Moon
            ctx.fillStyle = '#f1c40f';
            ctx.shadowColor = '#f1c40f';
            ctx.shadowBlur = 30;
            ctx.beginPath();
            ctx.arc(GAME_WIDTH - 100, 100, 40, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Stars
            ctx.fillStyle = 'white';
            for (const star of stars) {
                const alpha = 0.5 + Math.sin(star.twinkle) * 0.5;
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;

            // Mountains
            for (const m of mountains) {
                ctx.fillStyle = m.color;
                ctx.beginPath();
                ctx.moveTo(m.x, GROUND_Y);
                ctx.lineTo(m.x + m.w / 2, GROUND_Y - m.h);
                ctx.lineTo(m.x + m.w, GROUND_Y);
                ctx.fill();
            }

            // Bg Trees
            for (const t of bgTrees) {
                ctx.fillStyle = t.color;
                ctx.beginPath();
                ctx.moveTo(t.x, t.y);
                ctx.lineTo(t.x + t.w / 2, t.y - t.h);
                ctx.lineTo(t.x + t.w, t.y);
                ctx.fill();
            }

            // Ground
            ctx.fillStyle = '#ecf0f1';
            ctx.fillRect(0, GROUND_Y, GAME_WIDTH, GAME_HEIGHT - GROUND_Y);

            for (const house of houses) { drawHouse(house); }

            // Particles (Smoke & Trail)
            for (const p of particles) {
                ctx.globalAlpha = p.life;
                if (p.type === 'smoke') {
                    ctx.fillStyle = '#bdc3c7';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.fillStyle = '#f1c40f';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1.0;

            for (const gift of fallingGifts) { drawGift(gift); }
            drawSleigh();

            // Popups
            for (const p of popups) {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.font = 'bold 30px Fredoka One';
                ctx.fillText(p.text, p.x, p.y);
            }
            ctx.globalAlpha = 1.0;

            // Santa Speech
            if (santaSpeech) {
                ctx.fillStyle = 'white';
                ctx.beginPath();
                // Increased width from 60 to 100 to fit "Merry Christmas"
                ctx.ellipse(santaSpeech.x + 80, santaSpeech.y - 50, 100, 35, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(santaSpeech.x + 60, santaSpeech.y - 30);
                ctx.lineTo(santaSpeech.x + 50, santaSpeech.y - 10);
                ctx.lineTo(santaSpeech.x + 70, santaSpeech.y - 30);
                ctx.fill();

                ctx.fillStyle = 'black';
                ctx.font = '20px Fredoka One';
                ctx.textAlign = 'center';
                ctx.fillText(santaSpeech.text, santaSpeech.x + 80, santaSpeech.y - 45);
                ctx.textAlign = 'left';
            }

            // Snow
            ctx.fillStyle = 'white';
            for (const snow of snowParticles) {
                ctx.beginPath();
                ctx.arc(snow.x, snow.y, snow.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function dropGift() {
            if (!isRunning) return;
            const giftX = sleighX + 40;
            const giftY = sleighY + 25;
            if (fallingGifts.some(g => (g.y < giftY + 30 && g.y > giftY - 30) && (g.x < giftX + 30 && g.x > giftX - 30))) { return; }
            fallingGifts.push({ x: giftX, y: giftY, isFalling: true });
        }

        function handleKeyDown(event) {
            if (event.code === 'Space') {
                event.preventDefault();
                dropGift();
            } else if (event.code.startsWith('Arrow')) {
                keys[event.code] = true;
            }
        }

        function handleKeyUp(event) {
            if (event.code.startsWith('Arrow')) {
                keys[event.code] = false;
            }
        }

        function restartGame() {
            score = 0;
            sleighX = 100;
            sleighY = 100;
            keys = {};
            currentScrollSpeed = BASE_SCROLL_SPEED;
            scoreValueDisplay.textContent = score;
            houses = [];
            fallingGifts = [];
            particles = [];
            popups = [];
            santaSpeech = null;
            lastHouseX = GAME_WIDTH;

            // Initialize team positions (reindeer + sleigh)
            team = [];
            for (let i = 0; i < REINDEER_COUNT + 1; i++) {
                team.push({
                    x: sleighX + (REINDEER_COUNT - i) * REINDEER_SPACING,
                    y: sleighY,
                    targetY: sleighY
                });
            }

            initStars();
            initSnow();
            initMountains();
            initBgTrees();

            for (let i = 0; i < 5; i++) { generateHouse(); }
            isRunning = true;
            messageBox.classList.add('hidden');
        }

        window.onload = () => {
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            restartGame();
            gameLoop();
        };
    </script>
</body>

</html>