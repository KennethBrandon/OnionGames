<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Christmas Jump</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #0f172a;
            /* Dark blue night sky */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            /* Prevent pull-to-refresh on mobile */
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .screen {
            background: rgba(255, 255, 255, 0.9);
            padding: 2rem;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            pointer-events: auto;
            max-width: 80%;
            display: none;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 4px solid #c0392b;
            /* Christmas Red */
        }

        .screen.active {
            display: block;
        }

        h1 {
            color: #166534;
            /* Pine Green */
            margin: 0 0 10px 0;
            font-size: 2.5rem;
            text-shadow: 1px 1px 0px #fff;
        }

        p {
            color: #333;
            font-size: 1.1rem;
            margin-bottom: 20px;
        }

        button {
            background: #c0392b;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.1s, background 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            background: #e74c3c;
            transform: scale(1.05);
        }

        button:active {
            transform: scale(0.95);
        }

        #score-hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            z-index: 10;
        }

        #height-bar-container {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            height: 60%;
            width: 60px;
            /* Wider to look like a tree */
            background: rgba(20, 83, 45, 0.4);
            /* Dark pine semi-transparent */
            border-radius: 0;
            /* Remove radius for sharp corners */
            pointer-events: none;
            clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
            /* Triangle shape */
        }

        #height-bar-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 0%;
            background: linear-gradient(to top, #166534, #4ade80);
            /* Tree Green Gradient */
            transition: height 0.2s;
        }

        .touch-hint {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
            pointer-events: none;
        }

        #debug-btn {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s;
            pointer-events: auto;
            /* Ensure clickable */
        }

        #debug-btn:active {
            transform: scale(0.9);
            background: rgba(255, 255, 255, 0.3);
        }

        @keyframes popIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Mobile specific adjustments */
        @media (max-width: 600px) {
            h1 {
                font-size: 2rem;
            }

            .screen {
                padding: 1.5rem;
                width: 90%;
            }
        }
    </style>
</head>

<body>

    <canvas id="gameCanvas"></canvas>

    <div id="score-hud">Score: 0</div>

    <div id="height-bar-container">
        <div id="height-bar-fill"></div>
    </div>

    <!-- Debug Button -->
    <button id="debug-btn" onclick="debugJump()">ðŸš€</button>

    <div id="ui-layer">
        <!-- Start Screen -->
        <div id="start-screen" class="screen active">
            <h1>Tree Topper</h1>
            <p>Carry the Star to the top of the tree!</p>
            <p style="font-size: 0.9rem; color: #666;">
                Use <b>Arrow Keys</b> or <b>Tap Sides</b> to move.<br>
                Watch out for the Grinch! Jump on his head to defeat him.<br>
                Jump into <b>Slingshots</b> for a boost!
            </p>
            <button onclick="startGame()">Start Jumping</button>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="screen">
            <h1 style="color: #c0392b;">Oh no!</h1>
            <p>You dropped the star!</p>
            <p>Score: <span id="final-score">0</span></p>
            <button onclick="startGame()">Try Again</button>
        </div>

        <!-- Win Screen -->
        <div id="win-screen" class="screen">
            <h1 style="color: #f1c40f;">Merry Christmas!</h1>
            <p>You placed the star at the top!</p>
            <p>Final Score: <span id="win-score">0</span></p>
            <button onclick="startGame()">Play Again</button>
        </div>
    </div>

    <div class="touch-hint" id="touch-hint">Tap Left / Right to Move</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreHud = document.getElementById('score-hud');
        const heightBarFill = document.getElementById('height-bar-fill');
        const touchHint = document.getElementById('touch-hint');

        // Screens
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const winScreen = document.getElementById('win-screen');
        const finalScoreSpan = document.getElementById('final-score');
        const winScoreSpan = document.getElementById('win-score');

        // Game Constants
        let GAME_WIDTH = 0;
        let GAME_HEIGHT = 0;
        const GRAVITY = 0.1; /* Even lower gravity for very floaty jumps */
        const JUMP_FORCE = -8; /* High jump relative to low gravity */
        const MOVE_SPEED = 4; /* Slower horizontal movement for better control */
        const MAX_WIN_HEIGHT = 15000; // Height required to win (Increased)

        // Game State
        let gameState = 'MENU'; // MENU, PLAYING, GAMEOVER, WIN
        let score = 0;
        let maxScore = 0;
        let cameraY = 0;
        let animationFrameId;

        // Input State
        const keys = {
            ArrowLeft: false,
            ArrowRight: false
        };
        const touchInput = {
            left: false,
            right: false
        };

        // Entities
        let player;
        let platforms = [];
        let slingshots = []; // New
        let particles = [];
        let enemies = [];
        let treeTop;

        class Player {
            constructor() {
                this.width = 40;
                this.height = 40;
                this.x = GAME_WIDTH / 2 - this.width / 2;
                this.y = GAME_HEIGHT - 150;
                this.vx = 0;
                this.vy = 0;
                this.color = '#fff';
                this.direction = 1; // 1 right, -1 left
            }

            update() {
                // Movement Logic
                if (keys.ArrowLeft || touchInput.left) {
                    this.vx = -MOVE_SPEED;
                    this.direction = -1;
                } else if (keys.ArrowRight || touchInput.right) {
                    this.vx = MOVE_SPEED;
                    this.direction = 1;
                } else {
                    this.vx = 0;
                }

                // Physics
                this.x += this.vx;
                this.y += this.vy;
                this.vy += GRAVITY;

                // Screen Wrapping
                if (this.x + this.width < 0) {
                    this.x = GAME_WIDTH;
                } else if (this.x > GAME_WIDTH) {
                    this.x = -this.width;
                }

                // Check collisions (only when falling)
                if (this.vy > 0) {
                    for (let platform of platforms) {
                        if (
                            this.x < platform.x + platform.width &&
                            this.x + this.width > platform.x &&
                            this.y + this.height > platform.y &&
                            this.y + this.height < platform.y + platform.height + 10 // Tolerance
                        ) {
                            // Hit platform
                            this.vy = JUMP_FORCE;
                            createDust(this.x + this.width / 2, this.y + this.height);
                        }
                    }

                    // Check Slingshot Collision (Launch) - New
                    for (let slingshot of slingshots) {
                        let slingshotTop = slingshot.y - slingshot.height;
                        if (
                            !slingshot.launched &&
                            this.x < slingshot.x + slingshot.width / 2 &&
                            this.x + this.width > slingshot.x - slingshot.width / 2 &&
                            this.y + this.height > slingshotTop &&
                            this.y + this.height < slingshotTop + 25 // Tolerance region around the band
                        ) {
                            // Hit slingshot from above
                            this.vy = JUMP_FORCE * 2.5; // Super boost!
                            slingshot.launched = true;
                            createDust(this.x + this.width / 2, this.y + this.height);
                        }
                    }

                    // Check Tree Top Collision (Win)
                    if (treeTop) {
                        if (
                            this.x < treeTop.x + treeTop.width &&
                            this.x + this.width > treeTop.x &&
                            this.y < treeTop.y + treeTop.height &&
                            this.y + this.height > treeTop.y
                        ) {
                            winGame();
                        }
                    }

                    // Check Enemy Collision (Stomp)
                    for (let i = enemies.length - 1; i >= 0; i--) {
                        let enemy = enemies[i];
                        if (
                            this.x < enemy.x + enemy.width &&
                            this.x + this.width > enemy.x &&
                            this.y + this.height > enemy.y &&
                            this.y + this.height < enemy.y + enemy.height / 2 // Hit top half
                        ) {
                            // Stomped the grinch
                            this.vy = JUMP_FORCE; // Boost
                            createDust(enemy.x + enemy.width / 2, enemy.y + enemy.height);
                            enemies.splice(i, 1);
                            maxScore += 500; // Bonus points
                        }
                    }
                }

                // Check Enemy Collision (Death)
                // We check basic overlap here, but rely on the logic above to handle the "falling onto" case safely.
                // If we are here, it means we overlapped but weren't "falling onto the top half" enough to trigger the stomp,
                // or we are moving upwards.
                for (let enemy of enemies) {
                    if (
                        this.x < enemy.x + enemy.width &&
                        this.x + this.width > enemy.x &&
                        this.y < enemy.y + enemy.height &&
                        this.y + this.height > enemy.y
                    ) {
                        // Check if we already handled the stomp
                        // If player is falling and above enemy, we likely handled it.
                        // But if we are rising, or hitting side/bottom -> DEATH
                        const isStomp = (this.vy > 0 && this.y + this.height < enemy.y + enemy.height / 2 + 10);

                        if (!isStomp) {
                            gameOver();
                        }
                    }
                }

                // Game Over Check
                if (this.y > GAME_HEIGHT) {
                    gameOver();
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);

                // Flip if moving left
                if (this.direction === -1) ctx.scale(-1, 1);

                // Body (Snowman bottom)
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(0, 10, 15, 0, Math.PI * 2);
                ctx.fill();

                // Head (Snowman top)
                ctx.beginPath();
                ctx.arc(0, -10, 10, 0, Math.PI * 2);
                ctx.fill();

                // Eyes
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(4, -12, 1.5, 0, Math.PI * 2);
                ctx.arc(-2, -12, 1.5, 0, Math.PI * 2);
                ctx.fill();

                // Nose (Carrot)
                ctx.fillStyle = 'orange';
                ctx.beginPath();
                ctx.moveTo(0, -8);
                ctx.lineTo(8, -5);
                ctx.lineTo(0, -5);
                ctx.fill();

                // Santa Hat
                ctx.fillStyle = '#c0392b'; // Red
                ctx.beginPath();
                ctx.moveTo(-10, -15);
                ctx.lineTo(10, -15);
                ctx.lineTo(0, -35);
                ctx.fill();

                // Hat Pom Pom
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(0, -35, 4, 0, Math.PI * 2);
                ctx.fill();

                // Hat Trim
                ctx.beginPath();
                ctx.roundRect(-12, -18, 24, 6, 3);
                ctx.fill();

                // Scarf
                ctx.fillStyle = '#27ae60'; // Green
                ctx.beginPath();
                ctx.roundRect(-8, -2, 16, 4, 2);
                ctx.fill();
                ctx.beginPath();
                ctx.roundRect(2, 0, 4, 12, 2); // Scarf tail
                ctx.fill();

                // Holding the Star
                ctx.save();
                ctx.translate(14, 0); // Position at "hand"
                ctx.rotate(Math.PI / 4);
                drawStarShape(ctx, 0, 0, 8, 4, '#f1c40f');
                ctx.restore();

                ctx.restore();
            }
        }

        // Helper to draw a star shape
        function drawStarShape(ctx, cx, cy, spikes, outerRadius, innerRadius, color) {
            let rot = Math.PI / 2 * 3;
            let x = cx;
            let y = cy;
            let step = Math.PI / spikes;

            ctx.beginPath();
            ctx.moveTo(cx, cy - outerRadius)
            for (i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius;
                y = cy + Math.sin(rot) * outerRadius;
                ctx.lineTo(x, y)
                rot += step

                x = cx + Math.cos(rot) * innerRadius;
                y = cy + Math.sin(rot) * innerRadius;
                ctx.lineTo(x, y)
                rot += step
            }
            ctx.lineTo(cx, cy - outerRadius)
            ctx.closePath();
            ctx.fillStyle = arguments.length > 6 ? color : '#f1c40f';
            ctx.fill();
        }


        class Platform {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = 80;
                this.height = 20;
                this.type = type; // 'branch' or 'ornament'

                if (this.type === 'ornament') {
                    this.width = 40;
                    this.height = 40;
                }
            }

            draw() {
                if (this.type === 'branch') {
                    // Pine Branch Aesthetic

                    // Main Branch
                    ctx.fillStyle = '#5D4037'; // Brown wood
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y + this.height / 2);
                    ctx.lineTo(this.x + this.width, this.y + this.height / 2);
                    ctx.lineWidth = 4;
                    ctx.strokeStyle = '#5D4037';
                    ctx.stroke();

                    // Needles
                    ctx.fillStyle = '#166534'; // Deep Green
                    ctx.beginPath();
                    // Top jagged edge
                    ctx.moveTo(this.x, this.y + 5);
                    for (let i = 0; i <= this.width; i += 10) {
                        ctx.lineTo(this.x + i, this.y - 5 + (Math.random() * 5));
                        ctx.lineTo(this.x + i + 5, this.y + 5);
                    }
                    // Bottom jagged edge
                    for (let i = this.width; i >= 0; i -= 10) {
                        ctx.lineTo(this.x + i, this.y + 15 + (Math.random() * 5));
                        ctx.lineTo(this.x + i - 5, this.y + 5);
                    }
                    ctx.closePath();
                    ctx.fill();

                    // Snow on top (jagged)
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    for (let i = 0; i <= this.width; i += 8) {
                        ctx.lineTo(this.x + i, this.y - 3);
                        ctx.lineTo(this.x + i + 4, this.y);
                    }
                    ctx.lineTo(this.x + this.width, this.y + 5);
                    ctx.lineTo(this.x, this.y + 5);
                    ctx.fill();

                } else if (this.type === 'ornament') {
                    // Ornament Visual
                    ctx.fillStyle = '#c0392b'; // Red
                    // Shiny effect gradient
                    let grad = ctx.createRadialGradient(
                        this.x + this.width / 2 - 5, this.y + this.height / 2 - 5, 2,
                        this.x + this.width / 2, this.y + this.height / 2, 20
                    );
                    grad.addColorStop(0, '#e74c3c');
                    grad.addColorStop(1, '#922b21');
                    ctx.fillStyle = grad;

                    ctx.beginPath();
                    ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
                    ctx.fill();

                    // Cap gold
                    ctx.fillStyle = '#f1c40f';
                    ctx.fillRect(this.x + this.width / 2 - 5, this.y - 4, 10, 6);
                }
            }
        }

        class Enemy {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 40;
                this.height = 40;
                this.vx = 2; // Moving speed
                this.startX = x;
                this.range = 100; // Patrol range
                this.frame = 0;
            }

            update() {
                this.x += this.vx;

                // Bounce off edges or patrol limit
                if (this.x <= 0 || this.x + this.width >= GAME_WIDTH) {
                    this.vx *= -1;
                }

                // Simple animation frame counter
                this.frame++;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                if (this.vx < 0) ctx.scale(-1, 1);

                // Green Grinch Body (Furry)
                ctx.fillStyle = '#6ab04c';
                ctx.beginPath();
                ctx.ellipse(0, 0, 18, 20, 0, 0, Math.PI * 2);
                ctx.fill();

                // Fur details
                ctx.strokeStyle = '#488c2e';
                ctx.lineWidth = 1;
                for (let i = 0; i < 5; i++) {
                    ctx.beginPath();
                    let ang = Math.random() * Math.PI * 2;
                    let r = 18;
                    ctx.moveTo(Math.cos(ang) * r, Math.sin(ang) * r);
                    ctx.lineTo(Math.cos(ang) * (r + 3), Math.sin(ang) * (r + 3));
                    ctx.stroke();
                }

                // Eyes (Yellow and Mean)
                ctx.fillStyle = '#f9ca24';
                ctx.beginPath();
                ctx.ellipse(-6, -5, 4, 6, -0.3, 0, Math.PI * 2);
                ctx.ellipse(6, -5, 4, 6, 0.3, 0, Math.PI * 2);
                ctx.fill();

                // Pupils
                ctx.fillStyle = 'red';
                ctx.beginPath();
                ctx.arc(-6, -5, 1.5, 0, Math.PI * 2);
                ctx.arc(6, -5, 1.5, 0, Math.PI * 2);
                ctx.fill();

                // Eyebrows (Angry)
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-10, -10);
                ctx.lineTo(-2, -6);
                ctx.moveTo(10, -10);
                ctx.lineTo(2, -6);
                ctx.stroke();

                // Smile (Sneaky)
                ctx.beginPath();
                ctx.arc(0, 5, 8, 0.2, Math.PI - 0.2);
                ctx.stroke();

                ctx.restore();
            }
        }

        class TreeTop {
            constructor(y) {
                this.width = 60;
                this.height = 60;
                this.x = GAME_WIDTH / 2 - this.width / 2;
                this.y = y;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);

                // Tree Top Triangle
                ctx.fillStyle = '#166534';
                ctx.beginPath();
                ctx.moveTo(0, -30);
                ctx.lineTo(30, 30);
                ctx.lineTo(-30, 30);
                ctx.closePath();
                ctx.fill();

                // Snow
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.moveTo(0, -30);
                ctx.lineTo(10, -10);
                ctx.lineTo(-10, -10);
                ctx.fill();

                ctx.restore();
            }
        }

        class Slingshot {
            constructor(x, y) {
                this.x = x; // bottom-center x
                this.y = y; // bottom y
                this.width = 40;
                this.height = 60;
                this.launched = false;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                // Y-shape frame
                ctx.strokeStyle = '#8B4513'; // SaddleBrown
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(0, 0); // Base
                ctx.lineTo(0, -this.height / 2); // Stem
                ctx.lineTo(-this.width / 2, -this.height); // Left arm top
                ctx.moveTo(0, -this.height / 2);
                ctx.lineTo(this.width / 2, -this.height); // Right arm top
                ctx.stroke();

                // Elastic band
                if (!this.launched) {
                    ctx.strokeStyle = '#C0392B'; // Red band
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(-this.width / 2, -this.height);
                    ctx.quadraticCurveTo(0, -this.height + 20, this.width / 2, -this.height);
                    ctx.stroke();
                }

                ctx.restore();
            }
        }

        // Particle System for Snow and Jump Dust
        class Particle {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type; // 'snow' or 'dust'

                if (type === 'snow') {
                    this.vx = Math.random() * 2 - 1;
                    this.vy = Math.random() * 2 + 1;
                    this.size = Math.random() * 3 + 1;
                    this.life = 1000; // infinite basically
                } else {
                    this.vx = (Math.random() - 0.5) * 4;
                    this.vy = Math.random() * 2;
                    this.size = Math.random() * 5 + 2;
                    this.life = 30;
                    this.color = `rgba(255,255,255,${Math.random()})`;
                }
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                if (this.type === 'snow') {
                    if (this.y > GAME_HEIGHT) {
                        this.y = -10;
                        this.x = Math.random() * GAME_WIDTH;
                    }
                } else {
                    this.life--;
                    this.size *= 0.9;
                }
            }

            draw() {
                ctx.fillStyle = this.type === 'snow' ? 'rgba(255,255,255,0.6)' : this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function createDust(x, y) {
            for (let i = 0; i < 5; i++) {
                particles.push(new Particle(x, y, 'dust'));
            }
        }

        // Init
        function init() {
            resize();
            window.addEventListener('resize', resize);

            // Keyboard
            window.addEventListener('keydown', e => keys[e.code] = true);
            window.addEventListener('keyup', e => keys[e.code] = false);

            // Touch
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);
            canvas.addEventListener('touchcancel', handleTouchEnd);

            // Background Snow
            for (let i = 0; i < 50; i++) {
                let p = new Particle(Math.random() * GAME_WIDTH, Math.random() * GAME_HEIGHT, 'snow');
                particles.push(p);
            }

            // Start Loop
            loop();
        }

        function debugJump() {
            if (gameState === 'PLAYING') {
                // Boost score close to win height
                maxScore = Math.max(maxScore, MAX_WIN_HEIGHT - 400);

                // Visual feedback on button
                const btn = document.getElementById('debug-btn');
                btn.style.borderColor = '#4ade80';
                setTimeout(() => btn.style.borderColor = 'rgba(255, 255, 255, 0.3)', 300);
            }
        }

        function resize() {
            GAME_WIDTH = window.innerWidth;
            GAME_HEIGHT = window.innerHeight;
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;

            // Re-center player if resizing
            if (player) {
                if (player.x > GAME_WIDTH) player.x = GAME_WIDTH - 50;
            }
        }

        function handleTouchStart(e) {
            e.preventDefault();
            const touchX = e.touches[0].clientX;
            if (touchX < GAME_WIDTH / 2) {
                touchInput.left = true;
                touchInput.right = false;
            } else {
                touchInput.left = false;
                touchInput.right = true;
            }

            // Hide hint on first interaction
            if (touchHint.style.opacity !== '0') {
                touchHint.style.transition = 'opacity 0.5s';
                touchHint.style.opacity = '0';
            }
        }

        function handleTouchEnd(e) {
            // Check remaining touches
            if (e.touches.length === 0) {
                touchInput.left = false;
                touchInput.right = false;
            }
        }

        function resetGame() {
            score = 0;
            maxScore = 0;
            cameraY = 0;
            platforms = [];
            slingshots = []; // New
            enemies = [];
            particles = particles.filter(p => p.type === 'snow'); // Keep snow, remove dust
            treeTop = null;

            player = new Player();

            // Initial Platforms
            let y = GAME_HEIGHT - 50;
            while (y > -GAME_HEIGHT) { // Generate a screen and a half worth
                let x = Math.random() * (GAME_WIDTH - 70);

                // First platform always under player
                if (platforms.length === 0) {
                    x = GAME_WIDTH / 2 - 35;
                    y = GAME_HEIGHT - 100;
                }

                let type = Math.random() > 0.8 ? 'ornament' : 'branch';
                platforms.push(new Platform(x, y, type));
                y -= 90 + Math.random() * 40; // Gap between platforms
            }
        }

        function startGame() {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            resetGame();
            gameState = 'PLAYING';
        }

        function gameOver() {
            gameState = 'GAMEOVER';
            finalScoreSpan.innerText = Math.floor(maxScore);
            gameOverScreen.classList.add('active');
        }

        function winGame() {
            gameState = 'WIN';
            winScoreSpan.innerText = Math.floor(maxScore) + 1000; // Bonus
            winScreen.classList.add('active');
        }

        function update() {
            if (gameState !== 'PLAYING') {
                // Keep animating snow in background
                particles.forEach(p => {
                    if (p.type === 'snow') p.update();
                });
                return;
            }

            player.update();
            enemies.forEach(e => e.update());

            // Camera movement (Simulated by moving entities down)
            // When player crosses middle of screen
            if (player.y < GAME_HEIGHT / 2) {
                let diff = (GAME_HEIGHT / 2) - player.y;
                player.y += diff;
                cameraY += diff;
                maxScore += diff;

                platforms.forEach(p => p.y += diff);
                slingshots.forEach(s => s.y += diff); // New
                enemies.forEach(e => e.y += diff);

                // Move dust
                particles.forEach(p => {
                    if (p.type === 'dust') p.y += diff;
                });

                // Move Tree Top
                if (treeTop) treeTop.y += diff;
            }

            // Entity Clean up
            platforms = platforms.filter(p => p.y < GAME_HEIGHT + 50);
            slingshots = slingshots.filter(s => s.y - s.height < GAME_HEIGHT + 50); // New
            enemies = enemies.filter(e => e.y < GAME_HEIGHT + 50);

            // Add new platforms if we haven't reached the win height
            let minY = GAME_HEIGHT;
            platforms.forEach(p => minY = Math.min(minY, p.y));

            // Generate up to -50
            if (maxScore < MAX_WIN_HEIGHT) {
                while (minY > -50) {
                    let y = minY - (90 + Math.random() * 50);
                    let x = Math.random() * (GAME_WIDTH - 70);
                    let type = Math.random() > 0.8 ? 'ornament' : 'branch';
                    platforms.push(new Platform(x, y, type));

                    // Spawn Slingshot Logic - New
                    // Rare chance to spawn a slingshot (e.g., 1.5% chance)
                    if (Math.random() < 0.015 && maxScore < MAX_WIN_HEIGHT - 2000) { // Don't spawn too close to top
                        // Spawn slingshot. x is bottom-center, y is bottom.
                        // Platform y is its top. Let's place slingshot on a platform.
                        // A bit complex to find a platform here. Let's just spawn it in mid-air for now.
                        slingshots.push(new Slingshot(Math.random() * (GAME_WIDTH - 40) + 20, y - 50));
                    }

                    // Spawn Grinch Logic
                    // Start appearing at 1/4 height (earlier)
                    if (maxScore > MAX_WIN_HEIGHT / 4) {
                        // Chance increases as we go higher: from 10% to 30% chance per platform gen
                        let progress = (maxScore - (MAX_WIN_HEIGHT / 4)) / (MAX_WIN_HEIGHT * 3 / 4);
                        let spawnChance = 0.10 + (progress * 0.20);

                        if (Math.random() < spawnChance) {
                            // Spawn enemy above platform
                            enemies.push(new Enemy(Math.random() * (GAME_WIDTH - 40), y - 60));
                        }
                    }

                    minY = y;
                }
            } else if (!treeTop) {
                // Reached max height, spawn Tree Top
                treeTop = new TreeTop(minY - 150);
            }

            // Particles
            particles.forEach((p, index) => {
                p.update();
                if (p.life <= 0) particles.splice(index, 1);
            });

            // Update UI
            scoreHud.innerText = "Score: " + Math.floor(maxScore);
            let progress = Math.min((maxScore / MAX_WIN_HEIGHT) * 100, 100);
            heightBarFill.style.height = `${progress}%`;
        }

        function draw() {
            // Clear
            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            // Draw Background decorations (simple gradients or distant trees could go here)
            // Just particles for now
            particles.forEach(p => p.draw());

            // Draw Platforms
            platforms.forEach(p => p.draw());

            // Draw Slingshots - New
            slingshots.forEach(s => s.draw());

            // Draw Enemies
            enemies.forEach(e => e.draw());

            // Draw Tree Top
            if (treeTop) {
                treeTop.draw();
                // If we win, draw the star on top
                if (gameState === 'WIN') {
                    drawStarShape(ctx, treeTop.x + treeTop.width / 2, treeTop.y - 15, 5, 25, 12, '#f1c40f');
                }
            }

            // Draw Player (only if playing or in transient state)
            if (gameState === 'PLAYING') {
                player.draw();
            }
        }

        function loop() {
            update();
            draw();
            animationFrameId = requestAnimationFrame(loop);
        }

        // Start
        init();

    </script>
</body>

</html>