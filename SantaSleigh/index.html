<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-JV4DNLEE4R"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-JV4DNLEE4R');
    </script>

    <title>Operation: Sleigh Ride</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #020024 0%, #090979 35%, #00d4ff 100%);
            /* Fallback */
            background-color: #0f172a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* ... (rest of CSS remains mostly same, will update font later) ... */

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .screen {
            background: rgba(255, 255, 255, 0.95);
            padding: 2rem;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            pointer-events: auto;
            max-width: 80%;
            display: none;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 4px solid #c0392b;
        }

        .screen.active {
            display: block;
        }

        h1 {
            color: #c0392b;
            margin: 0 0 10px 0;
            font-size: 2.5rem;
            text-shadow: 1px 1px 0px #fff;
        }

        p {
            color: #333;
            font-size: 1.1rem;
            margin-bottom: 20px;
        }

        button {
            background: #166534;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.1s, background 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            background: #15803d;
            transform: scale(1.05);
        }

        button:active {
            transform: scale(0.95);
        }

        #score-hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            z-index: 10;
        }

        #distance-bar-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.5);
        }

        #health-bar-container {
            position: absolute;
            top: 50px;
            left: 20px;
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.5);
        }

        #health-bar-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(to right, #ef4444, #b91c1c);
            transition: width 0.2s ease-out;
        }

        #distance-bar-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, #f1c40f, #e67e22);
            transition: width 0.1s linear;
        }

        .touch-hint {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
            pointer-events: none;
        }

        /* Mobile Controls */
        .mobile-controls {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        @media (max-width: 768px),
        (max-height: 500px) {
            .mobile-controls {
                display: block;
            }
        }

        /* D-Pad Container */
        .dpad {
            position: absolute;
            left: 20px;
            bottom: 20px;
            width: 140px;
            height: 140px;
            pointer-events: auto;
        }

        .dpad-button {
            position: absolute;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 20px;
            user-select: none;
            transition: background 0.1s;
        }

        .dpad-button:active {
            background: rgba(255, 255, 255, 0.5);
        }

        .dpad-up {
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        .dpad-down {
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        .dpad-left {
            left: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        .dpad-right {
            right: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        /* Shoot Button */
        .shoot-button {
            position: absolute;
            right: 0;
            top: 0;
            width: 50%;
            height: 100%;
            background: rgba(255, 100, 100, 0.2);
            border-left: 2px solid rgba(255, 255, 255, 0.3);
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.6);
            font-size: 2rem;
            font-weight: bold;
            user-select: none;
            transition: background 0.1s, opacity 1s;
            opacity: 1;
        }

        .shoot-button:active {
            background: rgba(255, 100, 100, 0.4);
        }

        .shoot-button.hidden {
            opacity: 0;
        }

        #debug-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 8px;
            z-index: 1000;
            font-family: monospace;
            width: 200px;
            pointer-events: auto;
            display: none;
            /* Hidden by default */
        }

        #debug-panel h3 {
            margin-top: 0;
            font-size: 1rem;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
            cursor: move;
            /* Draggable cursor */
            user-select: none;
        }

        #debug-panel label {
            display: block;
            margin-top: 8px;
            font-size: 0.8rem;
        }

        #debug-panel input {
            width: 100%;
            margin-top: 2px;
        }

        @keyframes popIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }
    </style>
</head>

<body>

    <canvas id="gameCanvas"></canvas>

    <div id="score-hud">Score: 0 | Level: 1</div>

    <div id="health-bar-container">
        <div id="health-bar-fill"></div>
    </div>

    <div id="distance-bar-container">
        <div id="distance-bar-fill"></div>
    </div>

    <div id="debug-panel">
        <h3>Debug Menu</h3>
        <label>Scroll Speed: <span id="val-scroll">14.5</span></label>
        <input type="range" min="0" max="20" step="0.5" value="14.5" oninput="updateDebug('scroll', this.value)">

        <label>Player Speed: <span id="val-player">9.5</span></label>
        <input type="range" min="1" max="20" step="0.5" value="9.5" oninput="updateDebug('player', this.value)">

        <label>Enemy Speed Mult: <span id="val-enemy">2.9</span></label>
        <input type="range" min="0.1" max="5" step="0.1" value="2.9" oninput="updateDebug('enemy', this.value)">

        <label>Projectile Speed: <span id="val-proj">13</span></label>
        <input type="range" min="1" max="30" step="1" value="13" oninput="updateDebug('proj', this.value)">
    </div>

    <div id="ui-layer">
        <!-- Start Screen -->
        <div id="start-screen" class="screen active">
            <h1>Operation: Sleigh Ride</h1>
            <p>Deliver Christmas to the finish line!</p>
            <p style="font-size: 0.9rem; color: #666;">
                <b>Arrow Up/Down</b> to Fly.<br>
                <b>Spacebar</b> to drop Snow Globe Grenades.<br>
                Avoid the Grinches!
            </p>
            <button onclick="startGame()">Take Flight</button>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="screen">
            <h1 style="color: #c0392b;">Christmas Ruined!</h1>
            <p>The Grinch stopped the sleigh.</p>
            <p>Score: <span id="final-score">0</span></p>
            <button onclick="startGame()">Try Again</button>
        </div>

        <!-- Win Screen -->
        <div id="win-screen" class="screen">
            <h1 style="color: #f1c40f;">Mission Accomplished!</h1>
            <p>You delivered all the presents!</p>
            <p>Final Score: <span id="win-score">0</span></p>
            <button onclick="startGame()">Fly Again</button>
        </div>
    </div>

    <div class="touch-hint" id="touch-hint">Tap Left/Right (Up/Down) â€¢ Tap Center (Shoot)</div>

    <!-- Mobile Controls -->
    <div class="mobile-controls" id="mobile-controls">
        <!-- D-Pad -->
        <div class="dpad">
            <div class="dpad-button dpad-up" id="btn-up">â–²</div>
            <div class="dpad-button dpad-down" id="btn-down">â–¼</div>
            <div class="dpad-button dpad-left" id="btn-left">â—„</div>
            <div class="dpad-button dpad-right" id="btn-right">â–º</div>
        </div>

        <!-- Shoot Button -->
        <div class="shoot-button" id="btn-shoot">ðŸŽ¯ SHOOT</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreHud = document.getElementById('score-hud');

        const distanceBarFill = document.getElementById('distance-bar-fill');
        const healthBarFill = document.getElementById('health-bar-fill');

        // Screens
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const winScreen = document.getElementById('win-screen');
        const finalScoreSpan = document.getElementById('final-score');
        const winScoreSpan = document.getElementById('win-score');

        // Game Constants
        let GAME_WIDTH = 0;
        let GAME_HEIGHT = 0;
        let PLAYER_SPEED = 9.5;
        let SCROLL_SPEED = 14.5;
        let PROJECTILE_SPEED = 13;
        let ENEMY_SPEED_MULTIPLIER = 2.9;
        const FINISH_DISTANCE = 50000; // Distance to fly
        const SPAWN_RATE = 100; // Frames between spawns
        const MAX_AMMO = 25;
        const AMMO_PACK_AMOUNT = 10;

        // Game State
        let gameState = 'MENU'; // MENU, PLAYING, GAMEOVER, WIN
        let score = 0;
        let distance = 0;
        let level = 1;
        let animationFrameId;
        let frameCount = 0;
        let lastTime = 0;
        let timeScale = 1;
        // Analytics tracking
        let levelCompletedFlags = new Set();
        let totalAmmoCollected = 0;
        let gameOverCause = ''; // Track what caused game over

        // Input State
        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            Space: false
        };

        // Entities
        let player;
        let boss = null;
        let enemies = [];
        let projectiles = [];
        let particles = [];
        let stars = []; // Background stars
        let mountains = []; // Parallax mountains
        let houses = []; // Background houses
        let candyCanes = []; // Power-ups
        let candyCaneSpawnedForLevel = false;
        let terrain;
        let aurora;

        class Terrain {
            constructor() {
                this.points = [];
                this.segmentWidth = 50;
                this.totalSegments = Math.ceil(GAME_WIDTH / this.segmentWidth) + 2;
                this.offset = 0;

                // Init flat ground
                for (let i = 0; i < this.totalSegments; i++) {
                    this.points.push(50); // Height from bottom
                }
            }

            update() {
                this.offset += SCROLL_SPEED * timeScale;
                if (this.offset >= this.segmentWidth) {
                    this.offset -= this.segmentWidth;
                    this.points.shift();
                    // Generate new point based on difficulty
                    let lastPoint = this.points[this.points.length - 1];
                    let change = (Math.random() - 0.5) * 40 * (level * 0.5); // More jagged at higher levels
                    let newHeight = lastPoint + change;
                    // Clamp
                    if (newHeight < 20) newHeight = 20;
                    if (newHeight > 200) newHeight = 200;
                    this.points.push(newHeight);
                }
            }

            draw() {
                // Draw ground with gradient
                let gradient = ctx.createLinearGradient(0, GAME_HEIGHT - 200, 0, GAME_HEIGHT);
                gradient.addColorStop(0, '#e2e8f0'); // Light snow
                gradient.addColorStop(1, '#94a3b8'); // Shadowy snow

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(0, GAME_HEIGHT);
                for (let i = 0; i < this.points.length; i++) {
                    let x = i * this.segmentWidth - this.offset;
                    let y = GAME_HEIGHT - this.points[i];
                    ctx.lineTo(x, y);
                }
                ctx.lineTo(GAME_WIDTH, GAME_HEIGHT);
                ctx.closePath();
                ctx.fill();

                // Snow top highlight
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 8;
                ctx.lineCap = 'round';
                ctx.beginPath();
                for (let i = 0; i < this.points.length; i++) {
                    let x = i * this.segmentWidth - this.offset;
                    let y = GAME_HEIGHT - this.points[i];
                    if (i === 0) ctx.moveTo(x, y);
                    else {
                        // Smooth curves
                        let prevX = (i - 1) * this.segmentWidth - this.offset;
                        let prevY = GAME_HEIGHT - this.points[i - 1];
                        let cx = (prevX + x) / 2;
                        let cy = (prevY + y) / 2;
                        ctx.quadraticCurveTo(prevX, prevY, cx, cy);
                    }
                }
                ctx.stroke();
            }

            getHeightAt(x) {
                // Find segment
                let adjustedX = x + this.offset;
                let index = Math.floor(adjustedX / this.segmentWidth);
                if (index < 0 || index >= this.points.length - 1) return 0;

                let p1 = this.points[index];
                let p2 = this.points[index + 1];
                let t = (adjustedX % this.segmentWidth) / this.segmentWidth;

                // Interpolate
                let h = p1 + (p2 - p1) * t;
                return h;
            }
        }

        class Aurora {
            constructor() {
                this.offset = 0;
            }

            update() {
                this.offset += 0.005 * timeScale;
            }

            draw() {
                ctx.save();
                ctx.globalCompositeOperation = 'screen';

                // Create multiple layers of aurora
                for (let i = 0; i < 3; i++) {
                    let gradient = ctx.createLinearGradient(0, 0, GAME_WIDTH, 0);
                    gradient.addColorStop(0, 'rgba(0, 255, 128, 0)');
                    gradient.addColorStop(0.2, `rgba(0, 255, 128, ${0.2 - i * 0.05})`);
                    gradient.addColorStop(0.5, `rgba(0, 255, 255, ${0.3 - i * 0.05})`);
                    gradient.addColorStop(0.8, `rgba(128, 0, 255, ${0.2 - i * 0.05})`);
                    gradient.addColorStop(1, 'rgba(0, 255, 128, 0)');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);

                    // Wavy bottom
                    for (let x = 0; x <= GAME_WIDTH; x += 50) {
                        let y = 100 + i * 30 + Math.sin(x * 0.005 + this.offset + i) * 50 + Math.sin(x * 0.01 - this.offset * 2) * 30;
                        ctx.lineTo(x, y);
                    }

                    ctx.lineTo(GAME_WIDTH, 0);
                    ctx.closePath();
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        class Mountain {
            constructor(layer) {
                this.layer = layer; // 0 = far, 1 = near
                this.width = Math.random() * 400 + 300;
                this.height = Math.random() * 150 + 100 + (layer * 50);
                this.x = GAME_WIDTH + Math.random() * 100;
                this.y = GAME_HEIGHT - (layer === 0 ? 50 : 0); // Far mountains higher up
                this.color = layer === 0 ? '#1e293b' : '#334155'; // Darker for far

                // Generate jagged peaks
                this.points = [];
                let numPeaks = 3 + Math.floor(Math.random() * 3);
                let step = this.width / numPeaks;

                this.points.push({ x: 0, y: 0 });
                for (let i = 1; i < numPeaks; i++) {
                    let px = i * step + (Math.random() - 0.5) * step * 0.5;
                    let py = -this.height * (0.5 + Math.random() * 0.5); // Peak height
                    this.points.push({ x: px, y: py });
                }
                this.points.push({ x: this.width, y: 0 });
            }

            update() {
                let speed = SCROLL_SPEED * (this.layer === 0 ? 0.2 : 0.5);
                this.x -= speed * timeScale;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);

                for (let p of this.points) {
                    ctx.lineTo(this.x + p.x, this.y + p.y);
                }

                ctx.lineTo(this.x + this.width, this.y);
                ctx.closePath();
                ctx.fill();

                // Snow caps
                ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);

                let inSnow = false;
                for (let i = 0; i < this.points.length; i++) {
                    let p = this.points[i];
                    let absY = this.y + p.y;

                    // If peak is high enough (y is smaller), add snow
                    if (p.y < -this.height * 0.3) {
                        // Simple snow cap triangle on peak
                        let prev = this.points[i - 1] || { x: 0, y: 0 };
                        let next = this.points[i + 1] || { x: this.width, y: 0 };

                        // Draw snow cap
                        ctx.moveTo(this.x + p.x, this.y + p.y);
                        ctx.lineTo(this.x + p.x - 20, this.y + p.y + 40);
                        ctx.lineTo(this.x + p.x + 20, this.y + p.y + 40);
                        ctx.fill();
                    }
                }
            }
        }

        class AmmoPack {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 20;
                this.height = 20;
                this.collected = false;
                this.floatOffset = 0;
            }

            update(houseX, houseY) {
                this.x = houseX + 10; // Center on house roof roughly
                this.y = houseY - 25 + Math.sin(frameCount * 0.1) * 5; // Float
            }

            draw() {
                if (this.collected) return;
                ctx.save();
                ctx.translate(this.x, this.y);

                // Glow
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#fcd34d';

                // Box
                ctx.fillStyle = '#ef4444';
                ctx.fillRect(0, 0, 20, 20);

                // Ribbon
                ctx.fillStyle = '#fcd34d';
                ctx.fillRect(8, 0, 4, 20);
                ctx.fillRect(0, 8, 20, 4);

                ctx.restore();
            }
        }

        class CandyCane {
            constructor() {
                this.width = 30;
                this.height = 50;
                this.x = GAME_WIDTH + 50;
                this.y = GAME_HEIGHT - 100; // Default, will adjust to terrain
                this.collected = false;
            }

            update() {
                this.x -= SCROLL_SPEED * timeScale;

                // Sit on terrain
                if (terrain) {
                    let groundH = terrain.getHeightAt(this.x + this.width / 2);
                    this.y = GAME_HEIGHT - groundH - this.height;
                }
            }

            draw() {
                if (this.collected) return;
                ctx.save();
                ctx.translate(this.x, this.y);

                // Glow
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#fff';

                // Candy Cane Shape
                ctx.lineWidth = 8;
                ctx.lineCap = 'round';
                ctx.strokeStyle = '#fff';

                // Draw white base
                ctx.beginPath();
                ctx.moveTo(15, 50);
                ctx.lineTo(15, 15);
                ctx.bezierCurveTo(15, -5, 35, -5, 35, 15); // Hook
                ctx.stroke();

                // Red stripes (dashed line trick)
                ctx.strokeStyle = '#ef4444';
                ctx.setLineDash([8, 8]);
                ctx.lineDashOffset = -frameCount; // Animate stripes
                ctx.stroke();

                ctx.restore();
            }
        }

        class House {
            constructor() {
                this.type = Math.random() < 0.3 ? 'cabin' : (Math.random() < 0.3 ? 'mansion' : 'normal');

                if (this.type === 'mansion') {
                    this.width = Math.random() * 60 + 80;
                    this.height = Math.random() * 50 + 70;
                } else if (this.type === 'cabin') {
                    this.width = Math.random() * 30 + 40;
                    this.height = Math.random() * 30 + 40;
                } else {
                    this.width = Math.random() * 40 + 50;
                    this.height = Math.random() * 40 + 50;
                }

                this.x = GAME_WIDTH + 50;
                // Sit on terrain if possible, else bottom
                this.y = GAME_HEIGHT - this.height;

                // Colors based on type
                if (this.type === 'cabin') {
                    this.color = '#78350f'; // Wood
                } else if (this.type === 'mansion') {
                    this.color = Math.random() > 0.5 ? '#94a3b8' : '#cbd5e1'; // Stone/Marble
                } else {
                    this.color = Math.random() > 0.5 ? '#475569' : '#334155'; // Slate
                }

                this.windows = [];
                // Generate windows
                let rows = Math.floor(this.height / 20);
                let cols = Math.floor(this.width / 20);
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        // Skip door area (bottom center)
                        if (r >= rows - 2 && c >= Math.floor(cols / 2) - 1 && c <= Math.floor(cols / 2)) continue;

                        if (Math.random() > 0.4) {
                            this.windows.push({
                                x: c * 20 + 8,
                                y: r * 20 + 15,
                                on: Math.random() > 0.3
                            });
                        }
                    }
                }
                this.chimney = Math.random() > 0.3; // More chimneys

                // Christmas Lights
                this.lights = [];
                let numLights = Math.floor(this.width / 8);
                for (let i = 0; i < numLights; i++) {
                    this.lights.push({
                        x: i * 8,
                        color: ['#ef4444', '#22c55e', '#3b82f6', '#facc15'][Math.floor(Math.random() * 4)],
                        offset: Math.random() * 100
                    });
                }

                // Ammo Pack Chance
                if (Math.random() > 0.5) {
                    this.ammoPack = new AmmoPack(this.x, this.y);
                }
            }

            update() {
                this.x -= SCROLL_SPEED * timeScale; // Move with background

                // Adjust Y to sit on terrain
                if (terrain) {
                    let groundH = terrain.getHeightAt(this.x + this.width / 2);
                    this.y = GAME_HEIGHT - groundH - this.height + 10; // Embed slightly
                }

                // Chimney smoke
                if (this.chimney && Math.random() < 0.05 * timeScale) {
                    particles.push(new Particle(this.x + 10, this.y - 10, 'rgba(200, 200, 200, 0.5)'));
                }

                if (this.ammoPack) {
                    this.ammoPack.update(this.x + this.width / 2 - 10, this.y);
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                // House Body
                ctx.fillStyle = this.color;
                ctx.fillRect(0, 0, this.width, this.height);

                // Texture for Cabin
                if (this.type === 'cabin') {
                    ctx.fillStyle = 'rgba(0,0,0,0.1)';
                    for (let i = 10; i < this.height; i += 10) {
                        ctx.fillRect(0, i, this.width, 2);
                    }
                }

                // Roof
                ctx.fillStyle = '#1e293b'; // Darker roof base
                ctx.beginPath();
                if (this.type === 'cabin') {
                    // A-Frame
                    ctx.moveTo(-10, 0);
                    ctx.lineTo(this.width / 2, -this.height * 0.5);
                    ctx.lineTo(this.width + 10, 0);
                } else if (this.type === 'mansion') {
                    // Flat top with trim
                    ctx.moveTo(-5, 0);
                    ctx.lineTo(0, -15);
                    ctx.lineTo(this.width, -15);
                    ctx.lineTo(this.width + 5, 0);
                } else {
                    // Normal
                    ctx.moveTo(-5, 0);
                    ctx.lineTo(this.width / 2, -25);
                    ctx.lineTo(this.width + 5, 0);
                }
                ctx.fill();

                // Snow on roof
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                if (this.type === 'cabin') {
                    ctx.moveTo(-10, 0);
                    ctx.lineTo(this.width / 2, -this.height * 0.5);
                    ctx.lineTo(this.width + 10, 0);
                    ctx.lineTo(this.width + 10, 5);
                    ctx.lineTo(this.width / 2, -this.height * 0.5 + 5);
                    ctx.lineTo(-10, 5);
                } else if (this.type === 'mansion') {
                    ctx.moveTo(-5, 0);
                    ctx.lineTo(0, -15);
                    ctx.lineTo(this.width, -15);
                    ctx.lineTo(this.width + 5, 0);
                    ctx.lineTo(this.width + 5, 5);
                    ctx.lineTo(this.width, -10);
                    ctx.lineTo(0, -10);
                    ctx.lineTo(-5, 5);
                } else {
                    ctx.moveTo(-5, 0);
                    ctx.lineTo(this.width / 2, -25);
                    ctx.lineTo(this.width + 5, 0);
                    ctx.lineTo(this.width + 5, 5);
                    ctx.lineTo(this.width / 2, -20);
                    ctx.lineTo(-5, 5);
                }
                ctx.fill();

                // Christmas Lights
                for (let l of this.lights) {
                    let blink = Math.sin((frameCount + l.offset) * 0.1) > 0;
                    ctx.fillStyle = blink ? l.color : '#444';

                    let lx = l.x;
                    let ly = 2; // Hang from eaves

                    ctx.beginPath();
                    ctx.arc(lx, ly, 2, 0, Math.PI * 2);
                    ctx.fill();
                    if (blink) {
                        ctx.shadowBlur = 5;
                        ctx.shadowColor = l.color;
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                }

                // Chimney
                if (this.chimney) {
                    ctx.fillStyle = '#7f1d1d';
                    ctx.fillRect(5, -20, 10, 20);
                    ctx.fillStyle = '#fff'; // Snow cap
                    ctx.fillRect(4, -22, 12, 4);
                }

                // Windows
                for (let w of this.windows) {
                    if (w.x + 10 > this.width || w.y + 12 > this.height) continue;

                    if (w.on) {
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#fcd34d';
                        ctx.fillStyle = '#fcd34d';
                    } else {
                        ctx.shadowBlur = 0;
                        ctx.fillStyle = '#1e293b';
                    }

                    if (this.type === 'mansion') {
                        ctx.beginPath();
                        ctx.arc(w.x + 5, w.y, 5, Math.PI, 0);
                        ctx.rect(w.x, w.y, 10, 12);
                        ctx.fill();
                    } else {
                        ctx.fillRect(w.x, w.y, 10, 12);
                    }
                    ctx.shadowBlur = 0;
                }

                // Door
                ctx.fillStyle = '#451a03'; // Dark wood
                let doorW = 20;
                let doorH = 30;
                let doorX = (this.width - doorW) / 2;
                let doorY = this.height - doorH;
                ctx.fillRect(doorX, doorY, doorW, doorH);
                // Frame
                ctx.strokeStyle = '#78350f';
                ctx.lineWidth = 2;
                ctx.strokeRect(doorX, doorY, doorW, doorH);
                // Knob
                ctx.fillStyle = '#fcd34d';
                ctx.beginPath(); ctx.arc(doorX + 15, doorY + 15, 2, 0, Math.PI * 2); ctx.fill();
                // Wreath on door
                ctx.fillStyle = '#166534';
                ctx.beginPath(); ctx.arc(doorX + 10, doorY + 10, 5, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#ef4444';
                ctx.beginPath(); ctx.arc(doorX + 10, doorY + 8, 1.5, 0, Math.PI * 2); ctx.fill();

                ctx.restore();

                if (this.ammoPack) {
                    this.ammoPack.draw();
                }
            }
        }

        class Player {
            constructor() {
                this.width = 60;
                this.height = 40;
                this.x = 50;
                this.y = GAME_HEIGHT / 2;
                this.vy = 0;
                // this.speed is now dynamic via PLAYER_SPEED
                this.cooldown = 0;
                this.ammo = MAX_AMMO;
                this.maxHealth = 3;
                this.health = this.maxHealth;
                this.invulnerabilityTimer = 0;
                this.candyCaneTimer = 0;
            }

            takeDamage(amount) {
                if (this.invulnerabilityTimer > 0) return;

                this.health -= amount;
                if (this.health < 0) this.health = 0;

                // Update UI
                let pct = (this.health / this.maxHealth) * 100;
                healthBarFill.style.width = `${pct}%`;

                // Flash effect
                createExplosion(this.x + this.width / 2, this.y + this.height / 2, '#ef4444');

                if (this.health <= 0) {
                    gameOver();
                } else {
                    this.invulnerabilityTimer = 60; // 1 second invulnerability
                }
            }

            update() {
                if (keys.ArrowUp) {
                    this.y -= PLAYER_SPEED * timeScale;
                }
                if (keys.ArrowDown) {
                    this.y += PLAYER_SPEED * timeScale;
                }
                if (keys.ArrowLeft) {
                    this.x -= PLAYER_SPEED * timeScale;
                }
                if (keys.ArrowRight) {
                    this.x += PLAYER_SPEED * timeScale;
                }

                // Boundaries
                if (this.y < 0) this.y = 0;
                if (this.y + this.height > GAME_HEIGHT) this.y = GAME_HEIGHT - this.height;
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > GAME_WIDTH) this.x = GAME_WIDTH - this.width;

                // Shooting
                if (keys.Space && this.cooldown <= 0) {
                    this.shoot();
                    this.cooldown = 20; // Frames between shots
                }
                if (this.cooldown > 0) this.cooldown -= timeScale;

                // Magic Trail
                if (Math.random() < 0.2 * timeScale) {
                    particles.push(new Particle(this.x, this.y + 30, 'rgba(255, 215, 0, 0.6)'));
                }

                if (this.invulnerabilityTimer > 0) {
                    this.invulnerabilityTimer -= timeScale;
                }

                if (this.candyCaneTimer > 0) {
                    this.candyCaneTimer -= timeScale;
                }
            }

            shoot() {
                if (this.candyCaneTimer > 0) {
                    // Candy Cane Mode: Triple Shot
                    // Straight
                    projectiles.push(new Projectile(this.x + this.width / 2, this.y + this.height, PROJECTILE_SPEED, 0, 'candycane'));
                    // Up 45
                    projectiles.push(new Projectile(this.x + this.width / 2, this.y + this.height, PROJECTILE_SPEED * 0.94, -PROJECTILE_SPEED * 0.34, 'candycane')); // ~20 degrees up
                    projectiles.push(new Projectile(this.x + this.width / 2, this.y + this.height, PROJECTILE_SPEED * 0.94, PROJECTILE_SPEED * 0.34, 'candycane')); // ~20 degrees down

                    // Do not consume ammo
                } else if (this.ammo > 0) {
                    // Drop a snow globe grenade (moves down and right)
                    projectiles.push(new Projectile(this.x + this.width / 2, this.y + this.height));
                    this.ammo--;
                    updateHUD();
                }
            }

            draw() {
                if (this.invulnerabilityTimer > 0 && Math.floor(Date.now() / 100) % 2 === 0) {
                    return; // Flicker effect
                }
                ctx.save();
                ctx.translate(this.x, this.y);

                // --- Sleigh Body ---
                let sleighGrad = ctx.createLinearGradient(0, 0, 0, 40);
                sleighGrad.addColorStop(0, '#ef4444');
                sleighGrad.addColorStop(1, '#7f1d1d');
                ctx.fillStyle = sleighGrad;

                // Main body curve
                ctx.beginPath();
                ctx.moveTo(0, 20);
                ctx.bezierCurveTo(10, 45, 50, 45, 60, 20); // Rounded bottom
                ctx.lineTo(55, 10); // Back rest top (higher)
                ctx.quadraticCurveTo(50, 30, 10, 30); // Inner curve
                ctx.lineTo(0, 20);
                ctx.fill();

                // Gold Trim (Fancy)
                ctx.strokeStyle = '#fcd34d';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Side detail (swirl)
                ctx.beginPath();
                ctx.moveTo(15, 35);
                ctx.bezierCurveTo(25, 40, 35, 40, 45, 30);
                ctx.stroke();

                // Runners (More detailed)
                ctx.strokeStyle = '#fcd34d'; // Gold
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(5, 45);
                ctx.lineTo(55, 45);
                ctx.quadraticCurveTo(75, 35, 65, 15); // Curled front
                ctx.stroke();

                // Runner supports
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(15, 45); ctx.lineTo(15, 35);
                ctx.moveTo(45, 45); ctx.lineTo(45, 35);
                ctx.stroke();

                // --- Santa ---
                // Body
                ctx.fillStyle = '#dc2626';
                ctx.beginPath();
                ctx.ellipse(35, 20, 12, 15, -0.2, 0, Math.PI * 2);
                ctx.fill();

                // Beard
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(35, 15, 10, 0, Math.PI * 2);
                ctx.fill();
                // Fluffy beard bottom
                ctx.beginPath();
                ctx.arc(35, 20, 8, 0, Math.PI);
                ctx.fill();

                // Face
                ctx.fillStyle = '#ffcccc';
                ctx.beginPath();
                ctx.arc(35, 13, 6, 0, Math.PI * 2);
                ctx.fill();

                // Eyes
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(33, 12, 1, 0, Math.PI * 2);
                ctx.arc(37, 12, 1, 0, Math.PI * 2);
                ctx.fill();

                // Hat
                ctx.fillStyle = '#dc2626';
                ctx.beginPath();
                ctx.moveTo(25, 8);
                ctx.quadraticCurveTo(35, -10, 50, 15); // Floppy hat
                ctx.lineTo(35, 5);
                ctx.fill();
                // Hat Trim
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.ellipse(35, 8, 8, 3, 0, 0, Math.PI * 2);
                ctx.fill();
                // Pom pom
                ctx.beginPath(); ctx.arc(50, 15, 3, 0, Math.PI * 2); ctx.fill();

                // Bag of toys (Overflowing)
                ctx.fillStyle = '#166534'; // Green
                ctx.beginPath();
                ctx.arc(10, 10, 15, 0, Math.PI * 2);
                ctx.fill();
                // Texture
                ctx.strokeStyle = '#14532d';
                ctx.lineWidth = 1;
                ctx.beginPath(); ctx.arc(10, 10, 11, 0, Math.PI * 2); ctx.stroke();
                // A toy poking out
                ctx.fillStyle = '#f472b6'; // Pink box
                ctx.fillRect(5, -2, 8, 8);

                // --- Reindeer Team (9 Reindeer) ---
                // Layout: 4 pairs + 1 leader (Rudolph)
                // Position relative to sleigh front (approx x=60)

                let startX = 80;
                let startY = 20;
                let spacingX = 45;
                let spacingY = 15; // Vertical spread for pairs

                for (let i = 0; i < 9; i++) {
                    let row = Math.floor(i / 2);
                    let isTop = i % 2 === 0;

                    // Rudolph is last (index 8), centered
                    let rX, rY;
                    if (i === 8) {
                        rX = startX + 4 * spacingX;
                        rY = startY;
                    } else {
                        rX = startX + row * spacingX;
                        rY = startY + (isTop ? -10 : 10); // Spread pairs vertically
                    }

                    this.drawReindeer(ctx, rX, rY, i === 8);

                    // Reins connecting to previous
                    ctx.strokeStyle = '#5c4033'; // Leather
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    if (i < 2) {
                        // Connect to sleigh
                        ctx.moveTo(60, 20);
                        ctx.lineTo(rX, rY + 5);
                    } else if (i === 8) {
                        // Rudolph connects to front pair
                        ctx.moveTo(startX + 3 * spacingX, startY - 10 + 5);
                        ctx.lineTo(rX, rY + 5);
                        ctx.moveTo(startX + 3 * spacingX, startY + 10 + 5);
                        ctx.lineTo(rX, rY + 5);
                    } else {
                        // Connect to previous pair
                        let prevIndex = i - 2;
                        let prevRow = Math.floor(prevIndex / 2);
                        let prevX = startX + prevRow * spacingX;
                        let prevY = startY + (prevIndex % 2 === 0 ? -10 : 10);
                        ctx.moveTo(prevX, prevY + 5);
                        ctx.lineTo(rX, rY + 5);
                    }
                    ctx.stroke();
                }

                ctx.restore();
            }

            drawReindeer(ctx, x, y, isRudolph) {
                ctx.save();
                ctx.translate(x, y);

                // Leg movement
                let legOffset = Math.sin((Date.now() / 100 * (PLAYER_SPEED / 5)) + x) * 5;

                // Back Legs
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(5, 10); ctx.lineTo(0 + legOffset, 20);
                ctx.moveTo(15, 10); ctx.lineTo(20 - legOffset, 20);
                ctx.stroke();

                // Body
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.ellipse(10, 8, 12, 6, 0, 0, Math.PI * 2);
                ctx.fill();

                // Front Legs
                ctx.beginPath();
                ctx.moveTo(5, 10); ctx.lineTo(0 - legOffset, 20);
                ctx.moveTo(15, 10); ctx.lineTo(20 + legOffset, 20);
                ctx.stroke();

                // Head
                ctx.beginPath();
                ctx.ellipse(22, -2, 7, 5, -0.2, 0, Math.PI * 2);
                ctx.fill();

                // Antlers
                ctx.strokeStyle = '#D2B48C';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(22, -6); ctx.lineTo(28, -14);
                ctx.moveTo(22, -6); ctx.lineTo(18, -14);
                ctx.stroke();

                // Nose
                if (isRudolph) {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = 'red';
                    ctx.fillStyle = 'red';
                } else {
                    ctx.fillStyle = '#000';
                }
                ctx.beginPath();
                ctx.arc(28, -2, 2.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                ctx.restore();
            }
        }

        class Enemy {
            constructor() {
                let scale = 1 + (level * 0.2); // Bigger at higher levels
                this.width = 40 * scale;
                this.height = 40 * scale;
                this.x = GAME_WIDTH + 50;
                this.startY = Math.random() * (GAME_HEIGHT - 100) + 50;
                this.y = this.startY;
                this.baseVx = -(Math.random() * 3 + 2); // Base speed
                this.type = Math.random() > 0.5 ? 'grinch' : 'coal'; // Maybe different types later
                this.time = Math.random() * 100;
                this.amplitude = Math.random() * 50 + 20;
                this.frequency = Math.random() * 0.05 + 0.02;
            }

            update() {
                this.x += this.baseVx * ENEMY_SPEED_MULTIPLIER * timeScale;
                this.time += timeScale;
                this.y = this.startY + Math.sin(this.time * this.frequency) * this.amplitude;

                // Keep in bounds vertically
                if (this.y < 0) this.y = 0;
                if (this.y + this.height > GAME_HEIGHT) this.y = GAME_HEIGHT - this.height;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                // Animation for limbs
                let limbOffset = Math.sin(this.time * 0.2) * 5;

                // --- Grinch Body ---
                ctx.fillStyle = '#6ab04c'; // Green

                // Legs (Thicker)
                ctx.strokeStyle = '#6ab04c';
                ctx.lineWidth = 8;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(15, 30); ctx.lineTo(10 + limbOffset, 45);
                ctx.moveTo(25, 30); ctx.lineTo(30 - limbOffset, 45);
                ctx.stroke();

                // Arms (Thicker)
                ctx.beginPath();
                ctx.moveTo(10, 20); ctx.lineTo(0 - limbOffset, 10);
                ctx.moveTo(30, 20); ctx.lineTo(40 + limbOffset, 10);
                ctx.stroke();

                // Body (Furry oval)
                ctx.beginPath();
                ctx.ellipse(20, 25, 14, 18, 0, 0, Math.PI * 2);
                ctx.fill();

                // Fur texture
                ctx.strokeStyle = '#589640';
                ctx.lineWidth = 1;
                for (let i = 0; i < 10; i++) {
                    let fx = 10 + Math.random() * 20;
                    let fy = 15 + Math.random() * 20;
                    ctx.beginPath(); ctx.moveTo(fx, fy); ctx.lineTo(fx + 2, fy + 2); ctx.stroke();
                }

                // Scarf (Trailing)
                ctx.strokeStyle = '#c0392b';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(20, 15);
                ctx.quadraticCurveTo(35, 15, 45 + Math.sin(frameCount * 0.2) * 5, 15 + Math.cos(frameCount * 0.2) * 5);
                ctx.stroke();

                // --- Head ---
                // Furry effect (simple jagged circle)
                ctx.beginPath();
                for (let i = 0; i < Math.PI * 2; i += 0.4) {
                    let r = 14 + (Math.random() * 2);
                    let x = Math.cos(i) * r + 20;
                    let y = Math.sin(i) * r + 10;
                    ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();

                // Eyes
                ctx.fillStyle = '#f1c40f'; // Yellow
                ctx.beginPath();
                ctx.ellipse(15, 8, 4, 6, -0.3, 0, Math.PI * 2);
                ctx.ellipse(25, 8, 4, 6, 0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'red';
                ctx.beginPath();
                ctx.arc(15, 8, 1.5, 0, Math.PI * 2);
                ctx.arc(25, 8, 1.5, 0, Math.PI * 2);
                ctx.fill();

                // Eyebrows (Angry)
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(10, 4); ctx.lineTo(18, 8);
                ctx.moveTo(30, 4); ctx.lineTo(22, 8);
                ctx.stroke();

                // Snout/Nose
                ctx.fillStyle = '#589640';
                ctx.beginPath();
                ctx.ellipse(20, 14, 5, 3, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(20, 13, 1.5, 0, Math.PI * 2);
                ctx.fill();

                // Evil Smile
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(12, 18);
                ctx.quadraticCurveTo(20, 24, 28, 18);
                ctx.stroke();

                // Santa Hat (Mocking Santa)
                ctx.fillStyle = '#c0392b';
                ctx.beginPath();
                ctx.moveTo(10, 0);
                ctx.lineTo(30, 0);
                ctx.lineTo(20, -15);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.fillRect(8, -2, 24, 4); // Brim
                ctx.beginPath(); ctx.arc(20, -15, 3, 0, Math.PI * 2); ctx.fill(); // Pom

                // Jetpack / Sled (Improved)
                ctx.fillStyle = '#555';
                ctx.beginPath();
                ctx.roundRect(5, 20, 30, 20, 5);
                ctx.fill();
                // Metal rivets
                ctx.fillStyle = '#777';
                ctx.beginPath(); ctx.arc(8, 23, 1, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(32, 23, 1, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(8, 37, 1, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(32, 37, 1, 0, Math.PI * 2); ctx.fill();

                // Flame (Animated)
                ctx.fillStyle = '#f97316';
                ctx.beginPath();
                ctx.moveTo(15, 40);
                ctx.lineTo(20, 55 + Math.random() * 10);
                ctx.lineTo(25, 40);
                ctx.fill();
                ctx.fillStyle = '#fcd34d'; // Inner flame
                ctx.beginPath();
                ctx.moveTo(17, 40);
                ctx.lineTo(20, 50 + Math.random() * 5);
                ctx.lineTo(23, 40);
                ctx.fill();

                ctx.restore();
            }
        }

        class BossGrinch {
            constructor() {
                this.width = 120;
                this.height = 120;
                this.x = GAME_WIDTH + 100;
                this.y = GAME_HEIGHT / 2;
                this.targetY = GAME_HEIGHT / 2;
                this.vx = -2; // Initial entry speed
                this.health = 15;
                this.maxHealth = 15;
                this.attackCooldown = 100;
                this.state = 'entering'; // entering, fighting
                this.time = 0;
                this.flashTimer = 0;
            }

            update() {
                this.time += timeScale;
                if (this.flashTimer > 0) this.flashTimer -= timeScale;

                if (this.state === 'entering') {
                    // Fly in to a position on the right
                    if (this.x > GAME_WIDTH - 250) {
                        this.x += this.vx * timeScale;
                    } else {
                        this.state = 'fighting';
                    }
                } else if (this.state === 'fighting') {
                    // Hover up and down
                    this.y = (GAME_HEIGHT / 2) - 60 + Math.sin(this.time * 0.05) * 150;

                    // Attack
                    if (this.attackCooldown <= 0) {
                        this.attack();
                        this.attackCooldown = 120; // 2 seconds
                    }
                    this.attackCooldown -= timeScale;
                }

                // Keep in bounds
                if (this.y < 0) this.y = 0;
                if (this.y + this.height > GAME_HEIGHT) this.y = GAME_HEIGHT - this.height;
            }

            attack() {
                // Throw present at player
                let dx = player.x - this.x;
                let dy = player.y - this.y;
                let angle = Math.atan2(dy, dx);
                let speed = PROJECTILE_SPEED * 0.8;
                let vx = Math.cos(angle) * speed;
                let vy = Math.sin(angle) * speed;

                projectiles.push(new Projectile(this.x, this.y + this.height / 2, vx, vy, 'present'));
            }

            takeDamage(amount) {
                this.health -= amount;
                this.flashTimer = 10;
                createExplosion(this.x + this.width / 2, this.y + this.height / 2, '#6ab04c');

                if (this.health <= 0) {
                    // Boss Death
                    for (let i = 0; i < 20; i++) {
                        setTimeout(() => {
                            createExplosion(
                                this.x + Math.random() * this.width,
                                this.y + Math.random() * this.height,
                                '#6ab04c'
                            );
                        }, i * 100);
                    }
                    score += 5000;

                    // Track boss defeated
                    if (typeof gtag !== 'undefined') {
                        gtag('event', 'boss_defeated', {
                            'game_name': 'Operation: Sleigh Ride',
                            'boss_level': level
                        });
                    }

                    boss = null;
                    winGame();
                }
            }

            draw() {
                if (this.flashTimer > 0 && Math.floor(Date.now() / 50) % 2 === 0) return;

                ctx.save();
                ctx.translate(this.x, this.y);

                // Big Grinch
                // Body
                ctx.fillStyle = '#6ab04c';
                ctx.beginPath();
                ctx.ellipse(60, 60, 40, 50, 0, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.beginPath();
                ctx.arc(60, 30, 30, 0, Math.PI * 2);
                ctx.fill();

                // Face
                ctx.fillStyle = '#f1c40f'; // Yellow eyes
                ctx.beginPath();
                ctx.ellipse(50, 25, 8, 12, -0.2, 0, Math.PI * 2);
                ctx.ellipse(70, 25, 8, 12, 0.2, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'red'; // Pupils
                ctx.beginPath();
                ctx.arc(50, 25, 3, 0, Math.PI * 2);
                ctx.arc(70, 25, 3, 0, Math.PI * 2);
                ctx.fill();

                // Evil Smile
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(60, 40, 15, 0.2, Math.PI - 0.2);
                ctx.stroke();

                // Santa Hat
                ctx.fillStyle = '#c0392b';
                ctx.beginPath();
                ctx.moveTo(30, 10);
                ctx.lineTo(90, 10);
                ctx.lineTo(60, -40);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.fillRect(25, 5, 70, 10); // Brim
                ctx.beginPath(); ctx.arc(60, -40, 8, 0, Math.PI * 2); ctx.fill(); // Pom

                // Arms holding bag
                ctx.strokeStyle = '#6ab04c';
                ctx.lineWidth = 10;
                ctx.beginPath();
                ctx.moveTo(30, 60); ctx.lineTo(10, 80);
                ctx.moveTo(90, 60); ctx.lineTo(110, 80);
                ctx.stroke();

                // Bag of stolen gifts
                ctx.fillStyle = '#5d4037';
                ctx.beginPath();
                ctx.arc(60, 90, 30, 0, Math.PI, true);
                ctx.fill();

                ctx.restore();

                // Health Bar for Boss
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(this.x, this.y - 20, this.width, 10);
                ctx.fillStyle = '#ef4444';
                ctx.fillRect(this.x, this.y - 20, this.width * (this.health / this.maxHealth), 10);
            }
        }

        class Projectile {
            constructor(x, y, vx, vy, type) {
                this.x = x;
                this.y = y;
                this.radius = 8;
                this.vx = vx || PROJECTILE_SPEED; // Dynamic
                this.vy = vy || 0; // Straight forward
                this.type = type || 'snowglobe'; // 'snowglobe', 'candycane', 'present'
                this.rotation = 0;
            }

            update() {
                this.x += this.vx * timeScale;
                this.y += this.vy * timeScale;
                this.rotation += 0.2 * timeScale;

                // Trail
                if (Math.random() < 0.5 * timeScale) {
                    let color;
                    if (this.type === 'candycane') color = 'rgba(255, 200, 200, 0.5)';
                    else if (this.type === 'present') color = 'rgba(100, 255, 100, 0.5)';
                    else color = 'rgba(200, 240, 255, 0.5)';

                    particles.push(new Particle(this.x, this.y, color));
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                if (this.type === 'candycane') {
                    // Candy Cane Projectile
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ef4444';

                    ctx.lineWidth = 4;
                    ctx.lineCap = 'round';
                    ctx.strokeStyle = '#fff';

                    ctx.beginPath();
                    ctx.moveTo(0, 8);
                    ctx.lineTo(0, -4);
                    ctx.bezierCurveTo(0, -10, 8, -10, 8, -4);
                    ctx.stroke();

                    ctx.strokeStyle = '#ef4444';
                    ctx.setLineDash([4, 4]);
                    ctx.stroke();
                } else if (this.type === 'present') {
                    // Stolen Present Projectile
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#00ff00';

                    ctx.fillStyle = '#ef4444'; // Red box
                    ctx.fillRect(-8, -8, 16, 16);

                    ctx.fillStyle = '#fcd34d'; // Gold ribbon
                    ctx.fillRect(-2, -8, 4, 16);
                    ctx.fillRect(-8, -2, 16, 4);
                } else {
                    // Snow Globe
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#a5f3fc';

                    let grad = ctx.createRadialGradient(-2, -2, 2, 0, 0, 8);
                    grad.addColorStop(0, '#fff');
                    grad.addColorStop(1, '#0ea5e9');
                    ctx.fillStyle = grad;

                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.shadowBlur = 0;

                    // Base
                    ctx.fillStyle = '#334155';
                    ctx.fillRect(-4, 4, 8, 4);
                }

                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 5;
                this.vy = (Math.random() - 0.5) * 5;
                this.life = 30;
                this.color = color;
                this.size = Math.random() * 3 + 2;
            }

            update() {
                this.x += this.vx * timeScale;
                this.y += this.vy * timeScale;
                this.life -= timeScale;
                this.size *= Math.pow(0.9, timeScale);
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.life / 30;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        function createExplosion(x, y, color) {
            for (let i = 0; i < 10; i++) {
                particles.push(new Particle(x, y, color));
            }
        }

        function init() {
            resize();
            window.addEventListener('resize', resize);

            // Keyboard
            window.addEventListener('keydown', e => {
                if (e.code === 'Space') keys.Space = true;
                if (e.code === 'ArrowUp') keys.ArrowUp = true;
                if (e.code === 'ArrowDown') keys.ArrowDown = true;
                if (e.code === 'ArrowLeft') keys.ArrowLeft = true;
                if (e.code === 'ArrowRight') keys.ArrowRight = true;
            });
            window.addEventListener('keyup', e => {
                if (e.code === 'Space') keys.Space = false;
                if (e.code === 'ArrowUp') keys.ArrowUp = false;
                if (e.code === 'ArrowDown') keys.ArrowDown = false;
                if (e.code === 'ArrowLeft') keys.ArrowLeft = false;
                if (e.code === 'ArrowRight') keys.ArrowRight = false;
            });

            // Touch (Simple zones) - kept for backward compatibility
            canvas.addEventListener('touchstart', handleTouch);
            canvas.addEventListener('touchend', endTouch);
            canvas.addEventListener('touchmove', handleTouch);

            // Mobile Controls
            setupMobileControls();

            // Stars
            for (let i = 0; i < 150; i++) {
                stars.push({
                    x: Math.random() * window.innerWidth,
                    y: Math.random() * window.innerHeight * 0.8, // Keep stars in upper 80%
                    size: Math.random() * 2 + 0.5,
                    speed: Math.random() * 0.2 + 0.05,
                    alpha: Math.random(),
                    twinkleSpeed: Math.random() * 0.05
                });
            }

            // Init Mountains
            for (let i = 0; i < 5; i++) {
                let m = new Mountain(0);
                m.x = Math.random() * window.innerWidth;
                mountains.push(m);
            }
            for (let i = 0; i < 5; i++) {
                let m = new Mountain(1);
                m.x = Math.random() * window.innerWidth;
                mountains.push(m);
            }

            // Debug Menu Logic
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('d') === 't') {
                const debugPanel = document.getElementById('debug-panel');
                debugPanel.style.display = 'block';

                // Drag Logic
                const header = debugPanel.querySelector('h3');
                let isDragging = false;
                let offsetX, offsetY;

                header.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    offsetX = e.clientX - debugPanel.getBoundingClientRect().left;
                    offsetY = e.clientY - debugPanel.getBoundingClientRect().top;
                });

                window.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        debugPanel.style.left = `${e.clientX - offsetX}px`;
                        debugPanel.style.top = `${e.clientY - offsetY}px`;
                    }
                });

                window.addEventListener('mouseup', () => {
                    isDragging = false;
                });
            }
        }

        function setupMobileControls() {
            const btnUp = document.getElementById('btn-up');
            const btnDown = document.getElementById('btn-down');
            const btnLeft = document.getElementById('btn-left');
            const btnRight = document.getElementById('btn-right');
            const btnShoot = document.getElementById('btn-shoot');

            // Prevent default touch behavior
            const preventDefaultTouch = (e) => e.preventDefault();

            // D-Pad Up
            btnUp.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys.ArrowUp = true;
            });
            btnUp.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys.ArrowUp = false;
            });

            // D-Pad Down
            btnDown.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys.ArrowDown = true;
            });
            btnDown.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys.ArrowDown = false;
            });

            // D-Pad Left
            btnLeft.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys.ArrowLeft = true;
            });
            btnLeft.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys.ArrowLeft = false;
            });

            // D-Pad Right
            btnRight.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys.ArrowRight = true;
            });
            btnRight.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys.ArrowRight = false;
            });

            // Shoot Button
            btnShoot.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys.Space = true;
            });
            btnShoot.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys.Space = false;
            });
        }

        function handleTouch(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const width = window.innerWidth;
            const height = window.innerHeight;

            if (touch.clientX < width * 0.3) {
                // Left side -> Up? Or maybe divide screen vertically
                // Let's do: Top half = Up, Bottom half = Down
                if (touch.clientY < height / 2) keys.ArrowUp = true;
                else keys.ArrowDown = true;
            } else if (touch.clientX > width * 0.7) {
                // Right side -> Shoot
                keys.Space = true;
            } else {
                // Center -> Shoot
                keys.Space = true;
            }
        }

        function endTouch(e) {
            e.preventDefault();
            keys.ArrowUp = false;
            keys.ArrowDown = false;
            keys.Space = false;
        }

        function resize() {
            GAME_WIDTH = window.innerWidth;
            GAME_HEIGHT = window.innerHeight;
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;
            if (player) {
                player.y = Math.min(player.y, GAME_HEIGHT - 50);
            }
        }

        function startGame() {
            // Track game start
            if (typeof gtag !== 'undefined') {
                gtag('event', 'game_start', {
                    'game_name': 'Operation: Sleigh Ride',
                    'starting_level': 1
                });
            }

            gameState = 'PLAYING';
            score = 0;
            distance = 0;
            level = 1;
            updateHUD();
            startScreen.classList.remove('active');
            gameOverScreen.classList.remove('active');
            winScreen.classList.remove('active');

            // Hide shoot button after 5 seconds
            const shootBtn = document.getElementById('btn-shoot');
            if (shootBtn) {
                shootBtn.classList.remove('hidden');
                setTimeout(() => {
                    shootBtn.classList.add('hidden');
                }, 5000);
            }

            player = new Player();
            boss = null;
            healthBarFill.style.width = '100%'; // Reset health bar
            enemies = [];
            projectiles = [];
            particles = [];
            houses = [];
            candyCanes = [];
            candyCaneSpawnedForLevel = false;
            levelCompletedFlags.clear(); // Reset level tracking
            totalAmmoCollected = 0; // Reset ammo tracking
            gameOverCause = ''; // Reset cause
            terrain = new Terrain();
            aurora = new Aurora();

            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            lastTime = performance.now();
            gameLoop(lastTime);
        }

        function gameOver() {
            gameState = 'GAMEOVER';

            // Track game over
            if (typeof gtag !== 'undefined') {
                gtag('event', 'game_over', {
                    'game_name': 'Operation: Sleigh Ride',
                    'final_score': score,
                    'final_level': level,
                    'distance_traveled': Math.floor(distance),
                    'cause': gameOverCause || 'enemy',
                    'ammo_collected': totalAmmoCollected
                });
            }

            finalScoreSpan.innerText = score;
            gameOverScreen.classList.add('active');
        }

        function winGame() {
            gameState = 'WIN';

            // Track victory
            if (typeof gtag !== 'undefined') {
                gtag('event', 'victory', {
                    'game_name': 'Operation: Sleigh Ride',
                    'final_score': score,
                    'final_level': level,
                    'ammo_collected': totalAmmoCollected
                });
            }

            winScoreSpan.innerText = score;
            winScreen.classList.add('active');
        }

        function updateHUD() {
            let ammoText = player ? player.ammo : MAX_AMMO;
            scoreHud.innerText = `Score: ${score} | Level: ${level} | Ammo: ${ammoText}`;
        }

        function gameLoop(timestamp) {
            if (gameState !== 'PLAYING') return;

            // Calculate Delta Time
            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            // Cap dt to prevent huge jumps if tab is inactive (e.g. max 0.1s)
            const safeDt = Math.min(dt, 0.1);
            timeScale = safeDt * 60; // Normalize to 60 FPS

            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            // Update Distance & Level
            distance += SCROLL_SPEED * timeScale;
            let progress = Math.min(distance / FINISH_DISTANCE * 100, 100);
            distanceBarFill.style.width = `${progress}%`;

            // Level up every 20% of distance
            let newLevel = Math.floor(progress / 20) + 1;
            if (newLevel > 5) newLevel = 5;
            if (newLevel > level) {
                level = newLevel;
                candyCaneSpawnedForLevel = false; // Reset for new level
                updateHUD();

                // Track level completion
                if (!levelCompletedFlags.has(newLevel) && typeof gtag !== 'undefined') {
                    levelCompletedFlags.add(newLevel);
                    gtag('event', 'level_complete', {
                        'game_name': 'Operation: Sleigh Ride',
                        'level_number': newLevel
                    });
                }
            }

            if (distance >= FINISH_DISTANCE) {
                if (!boss) {
                    boss = new BossGrinch();
                }
            }

            // Draw Sky Gradient
            let skyGrad = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
            skyGrad.addColorStop(0, '#020024');
            skyGrad.addColorStop(0.4, '#090979');
            skyGrad.addColorStop(1, '#4b6cb7');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            // Draw Moon
            ctx.save();
            ctx.shadowBlur = 50;
            ctx.shadowColor = '#fff';
            ctx.fillStyle = '#fdfbf7';
            ctx.beginPath();
            ctx.arc(GAME_WIDTH - 100, 100, 40, 0, Math.PI * 2);
            ctx.fill();
            // Craters
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
            ctx.beginPath(); ctx.arc(GAME_WIDTH - 110, 90, 8, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(GAME_WIDTH - 90, 110, 12, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(GAME_WIDTH - 80, 80, 5, 0, Math.PI * 2); ctx.fill();
            ctx.restore();

            // Aurora
            if (aurora) {
                aurora.update();
                aurora.draw();
            }

            // Draw Stars (Background)
            ctx.fillStyle = '#fff';
            for (let star of stars) {
                star.x -= star.speed * timeScale;
                if (star.x < 0) star.x = GAME_WIDTH;

                // Twinkle
                star.alpha += star.twinkleSpeed;
                if (star.alpha > 1 || star.alpha < 0.2) star.twinkleSpeed *= -1;

                ctx.globalAlpha = star.alpha;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }

            // Draw Mountains (Parallax)
            // Spawn new mountains
            if (Math.random() < 0.01) mountains.push(new Mountain(0));
            if (Math.random() < 0.02) mountains.push(new Mountain(1));

            mountains.sort((a, b) => a.layer - b.layer); // Draw far first

            for (let i = mountains.length - 1; i >= 0; i--) {
                let m = mountains[i];
                m.update();
                m.draw();
                if (m.x + m.width < 0) mountains.splice(i, 1);
            }

            // Terrain
            terrain.update();
            terrain.draw();

            // Candy Canes
            if (!candyCaneSpawnedForLevel && Math.random() < 0.005) { // Random chance per frame if not spawned
                candyCanes.push(new CandyCane());
                candyCaneSpawnedForLevel = true;
            }

            for (let i = candyCanes.length - 1; i >= 0; i--) {
                let cc = candyCanes[i];
                cc.update();
                cc.draw();

                if (!cc.collected) {
                    if (
                        player.x < cc.x + cc.width &&
                        player.x + player.width > cc.x &&
                        player.y < cc.y + cc.height &&
                        player.y + player.height > cc.y
                    ) {
                        cc.collected = true;
                        player.candyCaneTimer = 600; // 10 seconds at 60fps
                        createExplosion(cc.x + 15, cc.y + 25, '#fff');
                        createExplosion(cc.x + 15, cc.y + 25, '#ef4444');
                    }
                }

                if (cc.x + cc.width < 0) {
                    candyCanes.splice(i, 1);
                }
            }

            // Spawn Houses
            if (Math.random() < (1 / 150) * timeScale) { // Approx every 150 frames
                houses.push(new House());
            }

            // Houses
            for (let i = houses.length - 1; i >= 0; i--) {
                let house = houses[i];
                house.update();
                house.draw();

                // Collision with House
                if (
                    player.x < house.x + house.width &&
                    player.x + player.width > house.x &&
                    player.y < house.y + house.height &&
                    player.y + player.height > house.y
                ) {
                    gameOverCause = 'wall';
                    player.takeDamage(3); // Instant kill
                }

                // Collision with Ammo Pack
                if (house.ammoPack && !house.ammoPack.collected) {
                    let ap = house.ammoPack;
                    if (
                        player.x < ap.x + ap.width &&
                        player.x + player.width > ap.x &&
                        player.y < ap.y + ap.height &&
                        player.y + player.height > ap.y
                    ) {
                        house.ammoPack.collected = true;
                        player.ammo = Math.min(player.ammo + AMMO_PACK_AMOUNT, MAX_AMMO);
                        totalAmmoCollected += AMMO_PACK_AMOUNT; // Track for analytics
                        updateHUD();
                        createExplosion(ap.x + 10, ap.y + 10, '#fcd34d'); // Gold explosion
                    }
                }

                if (house.x + house.width < 0) {
                    houses.splice(i, 1);
                }
            }

            // Player
            player.update();
            player.draw();

            // Terrain Collision
            // Terrain Collision
            let groundHeight = terrain.getHeightAt(player.x + player.width / 2);
            if (player.y + player.height > GAME_HEIGHT - groundHeight) {
                // Bounce up slightly to avoid getting stuck
                player.y = GAME_HEIGHT - groundHeight - player.height - 5;
                gameOverCause = 'ground';
                player.takeDamage(0.5);
            }

            // Spawn Enemies
            if (!boss) {
                frameCount += timeScale;
                let currentSpawnRate = Math.max(20, SPAWN_RATE - (level * 15)); // Faster spawn at higher levels
                if (frameCount >= currentSpawnRate) {
                    frameCount = 0; // Reset frameCount for spawning to keep it simple, or use modulo with accumulated value
                    enemies.push(new Enemy());
                }
            }

            // Enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                let enemy = enemies[i];
                enemy.update();
                enemy.draw();

                // Collision with Player
                if (
                    player.x < enemy.x + enemy.width &&
                    player.x + player.width > enemy.x &&
                    player.y < enemy.y + enemy.height &&
                    player.y + player.height > enemy.y
                ) {
                    gameOverCause = 'enemy';
                    player.takeDamage(1);
                }

                // Remove off-screen
                if (enemy.x + enemy.width < 0) {
                    enemies.splice(i, 1);
                }
            }

            // Projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                let p = projectiles[i];
                p.update();
                p.draw();

                // Check collision with enemies
                let hit = false;

                // Check Boss Collision
                if (boss && (p.type === 'snowglobe' || p.type === 'candycane')) {
                    if (
                        p.x > boss.x && p.x < boss.x + boss.width &&
                        p.y > boss.y && p.y < boss.y + boss.height
                    ) {
                        boss.takeDamage(1);
                        hit = true;
                        projectiles.splice(i, 1);
                        continue;
                    }
                }

                // Check Player Collision with Boss Projectiles
                if (p.type === 'present') {
                    if (
                        p.x > player.x && p.x < player.x + player.width &&
                        p.y > player.y && p.y < player.y + player.height
                    ) {
                        gameOverCause = 'boss';
                        player.takeDamage(1);
                        hit = true;
                        projectiles.splice(i, 1);
                        continue;
                    }
                }

                for (let j = enemies.length - 1; j >= 0; j--) {
                    let enemy = enemies[j];
                    if (
                        p.x > enemy.x && p.x < enemy.x + enemy.width &&
                        p.y > enemy.y && p.y < enemy.y + enemy.height
                    ) {
                        // Hit!
                        createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, '#6ab04c');
                        enemies.splice(j, 1);
                        hit = true;
                        score += 100;
                        updateHUD();
                        break;
                    }
                }

                if (hit || p.y > GAME_HEIGHT || p.x > GAME_WIDTH) {
                    projectiles.splice(i, 1);
                }
            }

            // Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.update();
                p.draw();
                if (p.life <= 0) particles.splice(i, 1);
            }

            // Boss Logic
            if (boss) {
                boss.update();
                boss.draw();

                // Boss collision with player body
                if (
                    player.x < boss.x + boss.width &&
                    player.x + player.width > boss.x &&
                    player.y < boss.y + boss.height &&
                    player.y + player.height > boss.y
                ) {
                    gameOverCause = 'boss';
                    player.takeDamage(1);
                }
            }

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function updateDebug(type, val) {
            val = parseFloat(val);
            if (type === 'scroll') { SCROLL_SPEED = val; document.getElementById('val-scroll').innerText = val; }
            if (type === 'player') { PLAYER_SPEED = val; document.getElementById('val-player').innerText = val; }
            if (type === 'enemy') { ENEMY_SPEED_MULTIPLIER = val; document.getElementById('val-enemy').innerText = val; }
            if (type === 'proj') { PROJECTILE_SPEED = val; document.getElementById('val-proj').innerText = val; }
        }

        init();

    </script>
</body>

</html>